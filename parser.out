Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    MULTI_COMMENT
    SINGLE_COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     type -> NUMBER
Rule 3     type -> BOOL
Rule 4     type -> STRING
Rule 5     type -> ANY
Rule 6     type -> type ARROW type
Rule 7     type -> L_PAR typelist R_PAR
Rule 8     typelist -> type COMMA typelist
Rule 9     typelist -> type
Rule 10    block -> statement
Rule 11    block -> statement block
Rule 12    statement -> expression SEMI
Rule 13    statement -> IDEN ASSIGN expression SEMI
Rule 14    statement -> LET IDEN SEMI
Rule 15    statement -> LET IDEN COLON type SEMI
Rule 16    statement -> LET IDEN ASSIGN expression SEMI
Rule 17    statement -> LET IDEN COLON type ASSIGN expression SEMI
Rule 18    statement -> RETURN expression SEMI
Rule 19    statement -> IF L_PAR expression R_PAR statement ELSE statement
Rule 20    statement -> IF L_PAR expression R_PAR statement
Rule 21    statement -> WHILE L_PAR expression R_PAR statement
Rule 22    statement -> L_BRC block R_BRC
Rule 23    statement -> BREAK SEMI
Rule 24    statement -> CONTINUE SEMI
Rule 25    expression -> binary_operation
Rule 26    expression -> unary_operation
Rule 27    expression -> L_PAR expression R_PAR
Rule 28    expression -> NUM_LIT
Rule 29    expression -> BOOL_LIT
Rule 30    expression -> STR_LIT
Rule 31    expression -> function_call
Rule 32    expression -> lambda
Rule 33    expression -> IDEN
Rule 34    binary_operation -> expression PLUS expression
Rule 35    binary_operation -> expression MINUS expression
Rule 36    binary_operation -> expression MULTIPLY expression
Rule 37    binary_operation -> expression DIVIDE expression
Rule 38    binary_operation -> expression MODULO expression
Rule 39    binary_operation -> expression EQ expression
Rule 40    binary_operation -> expression NEQ expression
Rule 41    binary_operation -> expression LT expression
Rule 42    binary_operation -> expression GT expression
Rule 43    binary_operation -> expression LEQ expression
Rule 44    binary_operation -> expression GEQ expression
Rule 45    binary_operation -> expression OR expression
Rule 46    binary_operation -> expression AND expression
Rule 47    unary_operation -> PLUS expression
Rule 48    unary_operation -> MINUS expression
Rule 49    unary_operation -> NOT expression
Rule 50    arg_list -> expression
Rule 51    arg_list -> expression COMMA arg_list
Rule 52    param_list -> IDEN COMMA param_list
Rule 53    param_list -> IDEN COLON type COMMA param_list
Rule 54    param_list -> IDEN
Rule 55    param_list -> IDEN COLON type
Rule 56    function_call -> expression L_PAR R_PAR
Rule 57    function_call -> expression L_PAR arg_list R_PAR
Rule 58    lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC
Rule 59    lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC
Rule 60    lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

Terminals, with rules where they appear

AND                  : 46
ANY                  : 5
ARROW                : 6 58 59 60
ASSIGN               : 13 16 17
BOOL                 : 3
BOOL_LIT             : 29
BREAK                : 23
COLON                : 15 17 53 55
COMMA                : 8 51 52 53
CONTINUE             : 24
DIVIDE               : 37
ELSE                 : 19
EQ                   : 39
GEQ                  : 44
GT                   : 42
IDEN                 : 13 14 15 16 17 33 52 53 54 55 60
IF                   : 19 20
LEQ                  : 43
LET                  : 14 15 16 17
LT                   : 41
L_BRC                : 22 58 59 60
L_PAR                : 7 19 20 21 27 56 57 58 59 60
MINUS                : 35 48
MODULO               : 38
MULTIPLY             : 36
MULTI_COMMENT        : 
NEQ                  : 40
NOT                  : 49
NUMBER               : 2
NUM_LIT              : 28
OR                   : 45
PLUS                 : 34 47
RETURN               : 18
R_BRC                : 22 58 59 60
R_PAR                : 7 19 20 21 27 56 57 58 59 60
SEMI                 : 12 13 14 15 16 17 18 23 24
SINGLE_COMMENT       : 
STRING               : 4
STR_LIT              : 30
WHILE                : 21
error                : 

Nonterminals, with rules where they appear

arg_list             : 51 57
binary_operation     : 25
block                : 1 11 22 58 59 60
expression           : 12 13 16 17 18 19 20 21 27 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 48 49 50 51 56 57
function_call        : 31
lambda               : 32
param_list           : 52 53 59
program              : 0
statement            : 10 11 19 19 20 21
type                 : 6 6 8 9 15 17 53 55
typelist             : 7 8
unary_operation      : 26

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (10) block -> . statement
    (11) block -> . statement block
    (12) statement -> . expression SEMI
    (13) statement -> . IDEN ASSIGN expression SEMI
    (14) statement -> . LET IDEN SEMI
    (15) statement -> . LET IDEN COLON type SEMI
    (16) statement -> . LET IDEN ASSIGN expression SEMI
    (17) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (18) statement -> . RETURN expression SEMI
    (19) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (20) statement -> . IF L_PAR expression R_PAR statement
    (21) statement -> . WHILE L_PAR expression R_PAR statement
    (22) statement -> . L_BRC block R_BRC
    (23) statement -> . BREAK SEMI
    (24) statement -> . CONTINUE SEMI
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    program                        shift and go to state 1
    block                          shift and go to state 2
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (10) block -> statement .
    (11) block -> statement . block
    (10) block -> . statement
    (11) block -> . statement block
    (12) statement -> . expression SEMI
    (13) statement -> . IDEN ASSIGN expression SEMI
    (14) statement -> . LET IDEN SEMI
    (15) statement -> . LET IDEN COLON type SEMI
    (16) statement -> . LET IDEN ASSIGN expression SEMI
    (17) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (18) statement -> . RETURN expression SEMI
    (19) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (20) statement -> . IF L_PAR expression R_PAR statement
    (21) statement -> . WHILE L_PAR expression R_PAR statement
    (22) statement -> . L_BRC block R_BRC
    (23) statement -> . BREAK SEMI
    (24) statement -> . CONTINUE SEMI
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    $end            reduce using rule 10 (block -> statement .)
    R_BRC           reduce using rule 10 (block -> statement .)
    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    statement                      shift and go to state 3
    block                          shift and go to state 24
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 4

    (12) statement -> expression . SEMI
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 5

    (13) statement -> IDEN . ASSIGN expression SEMI
    (33) expression -> IDEN .

    ASSIGN          shift and go to state 40
    SEMI            reduce using rule 33 (expression -> IDEN .)
    PLUS            reduce using rule 33 (expression -> IDEN .)
    MINUS           reduce using rule 33 (expression -> IDEN .)
    MULTIPLY        reduce using rule 33 (expression -> IDEN .)
    DIVIDE          reduce using rule 33 (expression -> IDEN .)
    MODULO          reduce using rule 33 (expression -> IDEN .)
    EQ              reduce using rule 33 (expression -> IDEN .)
    NEQ             reduce using rule 33 (expression -> IDEN .)
    LT              reduce using rule 33 (expression -> IDEN .)
    GT              reduce using rule 33 (expression -> IDEN .)
    LEQ             reduce using rule 33 (expression -> IDEN .)
    GEQ             reduce using rule 33 (expression -> IDEN .)
    OR              reduce using rule 33 (expression -> IDEN .)
    AND             reduce using rule 33 (expression -> IDEN .)
    L_PAR           reduce using rule 33 (expression -> IDEN .)


state 6

    (14) statement -> LET . IDEN SEMI
    (15) statement -> LET . IDEN COLON type SEMI
    (16) statement -> LET . IDEN ASSIGN expression SEMI
    (17) statement -> LET . IDEN COLON type ASSIGN expression SEMI

    IDEN            shift and go to state 41


state 7

    (18) statement -> RETURN . expression SEMI
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 42
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 8

    (19) statement -> IF . L_PAR expression R_PAR statement ELSE statement
    (20) statement -> IF . L_PAR expression R_PAR statement

    L_PAR           shift and go to state 44


state 9

    (27) expression -> L_PAR . expression R_PAR
    (58) lambda -> L_PAR . R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> L_PAR . param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> L_PAR . IDEN R_PAR ARROW L_BRC block R_BRC
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (52) param_list -> . IDEN COMMA param_list
    (53) param_list -> . IDEN COLON type COMMA param_list
    (54) param_list -> . IDEN
    (55) param_list -> . IDEN COLON type
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    R_PAR           shift and go to state 46
    IDEN            shift and go to state 48
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 45
    param_list                     shift and go to state 47
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 10

    (21) statement -> WHILE . L_PAR expression R_PAR statement

    L_PAR           shift and go to state 49


state 11

    (22) statement -> L_BRC . block R_BRC
    (10) block -> . statement
    (11) block -> . statement block
    (12) statement -> . expression SEMI
    (13) statement -> . IDEN ASSIGN expression SEMI
    (14) statement -> . LET IDEN SEMI
    (15) statement -> . LET IDEN COLON type SEMI
    (16) statement -> . LET IDEN ASSIGN expression SEMI
    (17) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (18) statement -> . RETURN expression SEMI
    (19) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (20) statement -> . IF L_PAR expression R_PAR statement
    (21) statement -> . WHILE L_PAR expression R_PAR statement
    (22) statement -> . L_BRC block R_BRC
    (23) statement -> . BREAK SEMI
    (24) statement -> . CONTINUE SEMI
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    block                          shift and go to state 50
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 12

    (23) statement -> BREAK . SEMI

    SEMI            shift and go to state 51


state 13

    (24) statement -> CONTINUE . SEMI

    SEMI            shift and go to state 52


state 14

    (25) expression -> binary_operation .

    SEMI            reduce using rule 25 (expression -> binary_operation .)
    PLUS            reduce using rule 25 (expression -> binary_operation .)
    MINUS           reduce using rule 25 (expression -> binary_operation .)
    MULTIPLY        reduce using rule 25 (expression -> binary_operation .)
    DIVIDE          reduce using rule 25 (expression -> binary_operation .)
    MODULO          reduce using rule 25 (expression -> binary_operation .)
    EQ              reduce using rule 25 (expression -> binary_operation .)
    NEQ             reduce using rule 25 (expression -> binary_operation .)
    LT              reduce using rule 25 (expression -> binary_operation .)
    GT              reduce using rule 25 (expression -> binary_operation .)
    LEQ             reduce using rule 25 (expression -> binary_operation .)
    GEQ             reduce using rule 25 (expression -> binary_operation .)
    OR              reduce using rule 25 (expression -> binary_operation .)
    AND             reduce using rule 25 (expression -> binary_operation .)
    L_PAR           reduce using rule 25 (expression -> binary_operation .)
    R_PAR           reduce using rule 25 (expression -> binary_operation .)
    COMMA           reduce using rule 25 (expression -> binary_operation .)


state 15

    (26) expression -> unary_operation .

    SEMI            reduce using rule 26 (expression -> unary_operation .)
    PLUS            reduce using rule 26 (expression -> unary_operation .)
    MINUS           reduce using rule 26 (expression -> unary_operation .)
    MULTIPLY        reduce using rule 26 (expression -> unary_operation .)
    DIVIDE          reduce using rule 26 (expression -> unary_operation .)
    MODULO          reduce using rule 26 (expression -> unary_operation .)
    EQ              reduce using rule 26 (expression -> unary_operation .)
    NEQ             reduce using rule 26 (expression -> unary_operation .)
    LT              reduce using rule 26 (expression -> unary_operation .)
    GT              reduce using rule 26 (expression -> unary_operation .)
    LEQ             reduce using rule 26 (expression -> unary_operation .)
    GEQ             reduce using rule 26 (expression -> unary_operation .)
    OR              reduce using rule 26 (expression -> unary_operation .)
    AND             reduce using rule 26 (expression -> unary_operation .)
    L_PAR           reduce using rule 26 (expression -> unary_operation .)
    R_PAR           reduce using rule 26 (expression -> unary_operation .)
    COMMA           reduce using rule 26 (expression -> unary_operation .)


state 16

    (28) expression -> NUM_LIT .

    SEMI            reduce using rule 28 (expression -> NUM_LIT .)
    PLUS            reduce using rule 28 (expression -> NUM_LIT .)
    MINUS           reduce using rule 28 (expression -> NUM_LIT .)
    MULTIPLY        reduce using rule 28 (expression -> NUM_LIT .)
    DIVIDE          reduce using rule 28 (expression -> NUM_LIT .)
    MODULO          reduce using rule 28 (expression -> NUM_LIT .)
    EQ              reduce using rule 28 (expression -> NUM_LIT .)
    NEQ             reduce using rule 28 (expression -> NUM_LIT .)
    LT              reduce using rule 28 (expression -> NUM_LIT .)
    GT              reduce using rule 28 (expression -> NUM_LIT .)
    LEQ             reduce using rule 28 (expression -> NUM_LIT .)
    GEQ             reduce using rule 28 (expression -> NUM_LIT .)
    OR              reduce using rule 28 (expression -> NUM_LIT .)
    AND             reduce using rule 28 (expression -> NUM_LIT .)
    L_PAR           reduce using rule 28 (expression -> NUM_LIT .)
    R_PAR           reduce using rule 28 (expression -> NUM_LIT .)
    COMMA           reduce using rule 28 (expression -> NUM_LIT .)


state 17

    (29) expression -> BOOL_LIT .

    SEMI            reduce using rule 29 (expression -> BOOL_LIT .)
    PLUS            reduce using rule 29 (expression -> BOOL_LIT .)
    MINUS           reduce using rule 29 (expression -> BOOL_LIT .)
    MULTIPLY        reduce using rule 29 (expression -> BOOL_LIT .)
    DIVIDE          reduce using rule 29 (expression -> BOOL_LIT .)
    MODULO          reduce using rule 29 (expression -> BOOL_LIT .)
    EQ              reduce using rule 29 (expression -> BOOL_LIT .)
    NEQ             reduce using rule 29 (expression -> BOOL_LIT .)
    LT              reduce using rule 29 (expression -> BOOL_LIT .)
    GT              reduce using rule 29 (expression -> BOOL_LIT .)
    LEQ             reduce using rule 29 (expression -> BOOL_LIT .)
    GEQ             reduce using rule 29 (expression -> BOOL_LIT .)
    OR              reduce using rule 29 (expression -> BOOL_LIT .)
    AND             reduce using rule 29 (expression -> BOOL_LIT .)
    L_PAR           reduce using rule 29 (expression -> BOOL_LIT .)
    R_PAR           reduce using rule 29 (expression -> BOOL_LIT .)
    COMMA           reduce using rule 29 (expression -> BOOL_LIT .)


state 18

    (30) expression -> STR_LIT .

    SEMI            reduce using rule 30 (expression -> STR_LIT .)
    PLUS            reduce using rule 30 (expression -> STR_LIT .)
    MINUS           reduce using rule 30 (expression -> STR_LIT .)
    MULTIPLY        reduce using rule 30 (expression -> STR_LIT .)
    DIVIDE          reduce using rule 30 (expression -> STR_LIT .)
    MODULO          reduce using rule 30 (expression -> STR_LIT .)
    EQ              reduce using rule 30 (expression -> STR_LIT .)
    NEQ             reduce using rule 30 (expression -> STR_LIT .)
    LT              reduce using rule 30 (expression -> STR_LIT .)
    GT              reduce using rule 30 (expression -> STR_LIT .)
    LEQ             reduce using rule 30 (expression -> STR_LIT .)
    GEQ             reduce using rule 30 (expression -> STR_LIT .)
    OR              reduce using rule 30 (expression -> STR_LIT .)
    AND             reduce using rule 30 (expression -> STR_LIT .)
    L_PAR           reduce using rule 30 (expression -> STR_LIT .)
    R_PAR           reduce using rule 30 (expression -> STR_LIT .)
    COMMA           reduce using rule 30 (expression -> STR_LIT .)


state 19

    (31) expression -> function_call .

    SEMI            reduce using rule 31 (expression -> function_call .)
    PLUS            reduce using rule 31 (expression -> function_call .)
    MINUS           reduce using rule 31 (expression -> function_call .)
    MULTIPLY        reduce using rule 31 (expression -> function_call .)
    DIVIDE          reduce using rule 31 (expression -> function_call .)
    MODULO          reduce using rule 31 (expression -> function_call .)
    EQ              reduce using rule 31 (expression -> function_call .)
    NEQ             reduce using rule 31 (expression -> function_call .)
    LT              reduce using rule 31 (expression -> function_call .)
    GT              reduce using rule 31 (expression -> function_call .)
    LEQ             reduce using rule 31 (expression -> function_call .)
    GEQ             reduce using rule 31 (expression -> function_call .)
    OR              reduce using rule 31 (expression -> function_call .)
    AND             reduce using rule 31 (expression -> function_call .)
    L_PAR           reduce using rule 31 (expression -> function_call .)
    R_PAR           reduce using rule 31 (expression -> function_call .)
    COMMA           reduce using rule 31 (expression -> function_call .)


state 20

    (32) expression -> lambda .

    SEMI            reduce using rule 32 (expression -> lambda .)
    PLUS            reduce using rule 32 (expression -> lambda .)
    MINUS           reduce using rule 32 (expression -> lambda .)
    MULTIPLY        reduce using rule 32 (expression -> lambda .)
    DIVIDE          reduce using rule 32 (expression -> lambda .)
    MODULO          reduce using rule 32 (expression -> lambda .)
    EQ              reduce using rule 32 (expression -> lambda .)
    NEQ             reduce using rule 32 (expression -> lambda .)
    LT              reduce using rule 32 (expression -> lambda .)
    GT              reduce using rule 32 (expression -> lambda .)
    LEQ             reduce using rule 32 (expression -> lambda .)
    GEQ             reduce using rule 32 (expression -> lambda .)
    OR              reduce using rule 32 (expression -> lambda .)
    AND             reduce using rule 32 (expression -> lambda .)
    L_PAR           reduce using rule 32 (expression -> lambda .)
    R_PAR           reduce using rule 32 (expression -> lambda .)
    COMMA           reduce using rule 32 (expression -> lambda .)


state 21

    (47) unary_operation -> PLUS . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 53
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 22

    (48) unary_operation -> MINUS . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 54
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 23

    (49) unary_operation -> NOT . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 55
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 24

    (11) block -> statement block .

    $end            reduce using rule 11 (block -> statement block .)
    R_BRC           reduce using rule 11 (block -> statement block .)


state 25

    (12) statement -> expression SEMI .

    IDEN            reduce using rule 12 (statement -> expression SEMI .)
    LET             reduce using rule 12 (statement -> expression SEMI .)
    RETURN          reduce using rule 12 (statement -> expression SEMI .)
    IF              reduce using rule 12 (statement -> expression SEMI .)
    WHILE           reduce using rule 12 (statement -> expression SEMI .)
    L_BRC           reduce using rule 12 (statement -> expression SEMI .)
    BREAK           reduce using rule 12 (statement -> expression SEMI .)
    CONTINUE        reduce using rule 12 (statement -> expression SEMI .)
    L_PAR           reduce using rule 12 (statement -> expression SEMI .)
    NUM_LIT         reduce using rule 12 (statement -> expression SEMI .)
    BOOL_LIT        reduce using rule 12 (statement -> expression SEMI .)
    STR_LIT         reduce using rule 12 (statement -> expression SEMI .)
    PLUS            reduce using rule 12 (statement -> expression SEMI .)
    MINUS           reduce using rule 12 (statement -> expression SEMI .)
    NOT             reduce using rule 12 (statement -> expression SEMI .)
    $end            reduce using rule 12 (statement -> expression SEMI .)
    R_BRC           reduce using rule 12 (statement -> expression SEMI .)
    ELSE            reduce using rule 12 (statement -> expression SEMI .)


state 26

    (34) binary_operation -> expression PLUS . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 56
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 27

    (35) binary_operation -> expression MINUS . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 57
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 28

    (36) binary_operation -> expression MULTIPLY . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 58
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 29

    (37) binary_operation -> expression DIVIDE . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 59
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 30

    (38) binary_operation -> expression MODULO . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 60
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 31

    (39) binary_operation -> expression EQ . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 61
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 32

    (40) binary_operation -> expression NEQ . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 62
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 33

    (41) binary_operation -> expression LT . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 63
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 34

    (42) binary_operation -> expression GT . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 64
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 35

    (43) binary_operation -> expression LEQ . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 65
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 36

    (44) binary_operation -> expression GEQ . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 66
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 37

    (45) binary_operation -> expression OR . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 67
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 38

    (46) binary_operation -> expression AND . expression
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 68
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 39

    (56) function_call -> expression L_PAR . R_PAR
    (57) function_call -> expression L_PAR . arg_list R_PAR
    (50) arg_list -> . expression
    (51) arg_list -> . expression COMMA arg_list
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    R_PAR           shift and go to state 70
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 69
    arg_list                       shift and go to state 71
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 40

    (13) statement -> IDEN ASSIGN . expression SEMI
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 72
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 41

    (14) statement -> LET IDEN . SEMI
    (15) statement -> LET IDEN . COLON type SEMI
    (16) statement -> LET IDEN . ASSIGN expression SEMI
    (17) statement -> LET IDEN . COLON type ASSIGN expression SEMI

    SEMI            shift and go to state 73
    COLON           shift and go to state 74
    ASSIGN          shift and go to state 75


state 42

    (18) statement -> RETURN expression . SEMI
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 76
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 43

    (33) expression -> IDEN .

    SEMI            reduce using rule 33 (expression -> IDEN .)
    PLUS            reduce using rule 33 (expression -> IDEN .)
    MINUS           reduce using rule 33 (expression -> IDEN .)
    MULTIPLY        reduce using rule 33 (expression -> IDEN .)
    DIVIDE          reduce using rule 33 (expression -> IDEN .)
    MODULO          reduce using rule 33 (expression -> IDEN .)
    EQ              reduce using rule 33 (expression -> IDEN .)
    NEQ             reduce using rule 33 (expression -> IDEN .)
    LT              reduce using rule 33 (expression -> IDEN .)
    GT              reduce using rule 33 (expression -> IDEN .)
    LEQ             reduce using rule 33 (expression -> IDEN .)
    GEQ             reduce using rule 33 (expression -> IDEN .)
    OR              reduce using rule 33 (expression -> IDEN .)
    AND             reduce using rule 33 (expression -> IDEN .)
    L_PAR           reduce using rule 33 (expression -> IDEN .)
    R_PAR           reduce using rule 33 (expression -> IDEN .)
    COMMA           reduce using rule 33 (expression -> IDEN .)


state 44

    (19) statement -> IF L_PAR . expression R_PAR statement ELSE statement
    (20) statement -> IF L_PAR . expression R_PAR statement
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 77
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 45

    (27) expression -> L_PAR expression . R_PAR
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    R_PAR           shift and go to state 78
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 46

    (58) lambda -> L_PAR R_PAR . ARROW L_BRC block R_BRC

    ARROW           shift and go to state 79


state 47

    (59) lambda -> L_PAR param_list . R_PAR ARROW L_BRC block R_BRC

    R_PAR           shift and go to state 80


state 48

    (60) lambda -> L_PAR IDEN . R_PAR ARROW L_BRC block R_BRC
    (33) expression -> IDEN .
    (52) param_list -> IDEN . COMMA param_list
    (53) param_list -> IDEN . COLON type COMMA param_list
    (54) param_list -> IDEN .
    (55) param_list -> IDEN . COLON type

  ! shift/reduce conflict for R_PAR resolved as shift
  ! shift/reduce conflict for R_PAR resolved as shift
    R_PAR           shift and go to state 81
    PLUS            reduce using rule 33 (expression -> IDEN .)
    MINUS           reduce using rule 33 (expression -> IDEN .)
    MULTIPLY        reduce using rule 33 (expression -> IDEN .)
    DIVIDE          reduce using rule 33 (expression -> IDEN .)
    MODULO          reduce using rule 33 (expression -> IDEN .)
    EQ              reduce using rule 33 (expression -> IDEN .)
    NEQ             reduce using rule 33 (expression -> IDEN .)
    LT              reduce using rule 33 (expression -> IDEN .)
    GT              reduce using rule 33 (expression -> IDEN .)
    LEQ             reduce using rule 33 (expression -> IDEN .)
    GEQ             reduce using rule 33 (expression -> IDEN .)
    OR              reduce using rule 33 (expression -> IDEN .)
    AND             reduce using rule 33 (expression -> IDEN .)
    L_PAR           reduce using rule 33 (expression -> IDEN .)
    COMMA           shift and go to state 82
    COLON           shift and go to state 83

  ! R_PAR           [ reduce using rule 33 (expression -> IDEN .) ]
  ! R_PAR           [ reduce using rule 54 (param_list -> IDEN .) ]


state 49

    (21) statement -> WHILE L_PAR . expression R_PAR statement
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 84
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 50

    (22) statement -> L_BRC block . R_BRC

    R_BRC           shift and go to state 85


state 51

    (23) statement -> BREAK SEMI .

    IDEN            reduce using rule 23 (statement -> BREAK SEMI .)
    LET             reduce using rule 23 (statement -> BREAK SEMI .)
    RETURN          reduce using rule 23 (statement -> BREAK SEMI .)
    IF              reduce using rule 23 (statement -> BREAK SEMI .)
    WHILE           reduce using rule 23 (statement -> BREAK SEMI .)
    L_BRC           reduce using rule 23 (statement -> BREAK SEMI .)
    BREAK           reduce using rule 23 (statement -> BREAK SEMI .)
    CONTINUE        reduce using rule 23 (statement -> BREAK SEMI .)
    L_PAR           reduce using rule 23 (statement -> BREAK SEMI .)
    NUM_LIT         reduce using rule 23 (statement -> BREAK SEMI .)
    BOOL_LIT        reduce using rule 23 (statement -> BREAK SEMI .)
    STR_LIT         reduce using rule 23 (statement -> BREAK SEMI .)
    PLUS            reduce using rule 23 (statement -> BREAK SEMI .)
    MINUS           reduce using rule 23 (statement -> BREAK SEMI .)
    NOT             reduce using rule 23 (statement -> BREAK SEMI .)
    $end            reduce using rule 23 (statement -> BREAK SEMI .)
    R_BRC           reduce using rule 23 (statement -> BREAK SEMI .)
    ELSE            reduce using rule 23 (statement -> BREAK SEMI .)


state 52

    (24) statement -> CONTINUE SEMI .

    IDEN            reduce using rule 24 (statement -> CONTINUE SEMI .)
    LET             reduce using rule 24 (statement -> CONTINUE SEMI .)
    RETURN          reduce using rule 24 (statement -> CONTINUE SEMI .)
    IF              reduce using rule 24 (statement -> CONTINUE SEMI .)
    WHILE           reduce using rule 24 (statement -> CONTINUE SEMI .)
    L_BRC           reduce using rule 24 (statement -> CONTINUE SEMI .)
    BREAK           reduce using rule 24 (statement -> CONTINUE SEMI .)
    CONTINUE        reduce using rule 24 (statement -> CONTINUE SEMI .)
    L_PAR           reduce using rule 24 (statement -> CONTINUE SEMI .)
    NUM_LIT         reduce using rule 24 (statement -> CONTINUE SEMI .)
    BOOL_LIT        reduce using rule 24 (statement -> CONTINUE SEMI .)
    STR_LIT         reduce using rule 24 (statement -> CONTINUE SEMI .)
    PLUS            reduce using rule 24 (statement -> CONTINUE SEMI .)
    MINUS           reduce using rule 24 (statement -> CONTINUE SEMI .)
    NOT             reduce using rule 24 (statement -> CONTINUE SEMI .)
    $end            reduce using rule 24 (statement -> CONTINUE SEMI .)
    R_BRC           reduce using rule 24 (statement -> CONTINUE SEMI .)
    ELSE            reduce using rule 24 (statement -> CONTINUE SEMI .)


state 53

    (47) unary_operation -> PLUS expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 47 (unary_operation -> PLUS expression .)
    PLUS            reduce using rule 47 (unary_operation -> PLUS expression .)
    MINUS           reduce using rule 47 (unary_operation -> PLUS expression .)
    MULTIPLY        reduce using rule 47 (unary_operation -> PLUS expression .)
    DIVIDE          reduce using rule 47 (unary_operation -> PLUS expression .)
    MODULO          reduce using rule 47 (unary_operation -> PLUS expression .)
    EQ              reduce using rule 47 (unary_operation -> PLUS expression .)
    NEQ             reduce using rule 47 (unary_operation -> PLUS expression .)
    LT              reduce using rule 47 (unary_operation -> PLUS expression .)
    GT              reduce using rule 47 (unary_operation -> PLUS expression .)
    LEQ             reduce using rule 47 (unary_operation -> PLUS expression .)
    GEQ             reduce using rule 47 (unary_operation -> PLUS expression .)
    OR              reduce using rule 47 (unary_operation -> PLUS expression .)
    AND             reduce using rule 47 (unary_operation -> PLUS expression .)
    L_PAR           reduce using rule 47 (unary_operation -> PLUS expression .)
    R_PAR           reduce using rule 47 (unary_operation -> PLUS expression .)
    COMMA           reduce using rule 47 (unary_operation -> PLUS expression .)

  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MULTIPLY        [ shift and go to state 28 ]
  ! DIVIDE          [ shift and go to state 29 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 54

    (48) unary_operation -> MINUS expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 48 (unary_operation -> MINUS expression .)
    PLUS            reduce using rule 48 (unary_operation -> MINUS expression .)
    MINUS           reduce using rule 48 (unary_operation -> MINUS expression .)
    MULTIPLY        reduce using rule 48 (unary_operation -> MINUS expression .)
    DIVIDE          reduce using rule 48 (unary_operation -> MINUS expression .)
    MODULO          reduce using rule 48 (unary_operation -> MINUS expression .)
    EQ              reduce using rule 48 (unary_operation -> MINUS expression .)
    NEQ             reduce using rule 48 (unary_operation -> MINUS expression .)
    LT              reduce using rule 48 (unary_operation -> MINUS expression .)
    GT              reduce using rule 48 (unary_operation -> MINUS expression .)
    LEQ             reduce using rule 48 (unary_operation -> MINUS expression .)
    GEQ             reduce using rule 48 (unary_operation -> MINUS expression .)
    OR              reduce using rule 48 (unary_operation -> MINUS expression .)
    AND             reduce using rule 48 (unary_operation -> MINUS expression .)
    L_PAR           reduce using rule 48 (unary_operation -> MINUS expression .)
    R_PAR           reduce using rule 48 (unary_operation -> MINUS expression .)
    COMMA           reduce using rule 48 (unary_operation -> MINUS expression .)

  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MULTIPLY        [ shift and go to state 28 ]
  ! DIVIDE          [ shift and go to state 29 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 55

    (49) unary_operation -> NOT expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 49 (unary_operation -> NOT expression .)
    PLUS            reduce using rule 49 (unary_operation -> NOT expression .)
    MINUS           reduce using rule 49 (unary_operation -> NOT expression .)
    MULTIPLY        reduce using rule 49 (unary_operation -> NOT expression .)
    DIVIDE          reduce using rule 49 (unary_operation -> NOT expression .)
    MODULO          reduce using rule 49 (unary_operation -> NOT expression .)
    EQ              reduce using rule 49 (unary_operation -> NOT expression .)
    NEQ             reduce using rule 49 (unary_operation -> NOT expression .)
    LT              reduce using rule 49 (unary_operation -> NOT expression .)
    GT              reduce using rule 49 (unary_operation -> NOT expression .)
    LEQ             reduce using rule 49 (unary_operation -> NOT expression .)
    GEQ             reduce using rule 49 (unary_operation -> NOT expression .)
    OR              reduce using rule 49 (unary_operation -> NOT expression .)
    AND             reduce using rule 49 (unary_operation -> NOT expression .)
    L_PAR           reduce using rule 49 (unary_operation -> NOT expression .)
    R_PAR           reduce using rule 49 (unary_operation -> NOT expression .)
    COMMA           reduce using rule 49 (unary_operation -> NOT expression .)

  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MULTIPLY        [ shift and go to state 28 ]
  ! DIVIDE          [ shift and go to state 29 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 56

    (34) binary_operation -> expression PLUS expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 34 (binary_operation -> expression PLUS expression .)
    PLUS            reduce using rule 34 (binary_operation -> expression PLUS expression .)
    MINUS           reduce using rule 34 (binary_operation -> expression PLUS expression .)
    MODULO          reduce using rule 34 (binary_operation -> expression PLUS expression .)
    EQ              reduce using rule 34 (binary_operation -> expression PLUS expression .)
    NEQ             reduce using rule 34 (binary_operation -> expression PLUS expression .)
    LT              reduce using rule 34 (binary_operation -> expression PLUS expression .)
    GT              reduce using rule 34 (binary_operation -> expression PLUS expression .)
    LEQ             reduce using rule 34 (binary_operation -> expression PLUS expression .)
    GEQ             reduce using rule 34 (binary_operation -> expression PLUS expression .)
    OR              reduce using rule 34 (binary_operation -> expression PLUS expression .)
    AND             reduce using rule 34 (binary_operation -> expression PLUS expression .)
    L_PAR           reduce using rule 34 (binary_operation -> expression PLUS expression .)
    R_PAR           reduce using rule 34 (binary_operation -> expression PLUS expression .)
    COMMA           reduce using rule 34 (binary_operation -> expression PLUS expression .)
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29

  ! MULTIPLY        [ reduce using rule 34 (binary_operation -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 34 (binary_operation -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 57

    (35) binary_operation -> expression MINUS expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 35 (binary_operation -> expression MINUS expression .)
    PLUS            reduce using rule 35 (binary_operation -> expression MINUS expression .)
    MINUS           reduce using rule 35 (binary_operation -> expression MINUS expression .)
    MODULO          reduce using rule 35 (binary_operation -> expression MINUS expression .)
    EQ              reduce using rule 35 (binary_operation -> expression MINUS expression .)
    NEQ             reduce using rule 35 (binary_operation -> expression MINUS expression .)
    LT              reduce using rule 35 (binary_operation -> expression MINUS expression .)
    GT              reduce using rule 35 (binary_operation -> expression MINUS expression .)
    LEQ             reduce using rule 35 (binary_operation -> expression MINUS expression .)
    GEQ             reduce using rule 35 (binary_operation -> expression MINUS expression .)
    OR              reduce using rule 35 (binary_operation -> expression MINUS expression .)
    AND             reduce using rule 35 (binary_operation -> expression MINUS expression .)
    L_PAR           reduce using rule 35 (binary_operation -> expression MINUS expression .)
    R_PAR           reduce using rule 35 (binary_operation -> expression MINUS expression .)
    COMMA           reduce using rule 35 (binary_operation -> expression MINUS expression .)
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29

  ! MULTIPLY        [ reduce using rule 35 (binary_operation -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 35 (binary_operation -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 58

    (36) binary_operation -> expression MULTIPLY expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    PLUS            reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    MINUS           reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    MULTIPLY        reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    DIVIDE          reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    MODULO          reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    EQ              reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    NEQ             reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    LT              reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    GT              reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    LEQ             reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    GEQ             reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    OR              reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    AND             reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    L_PAR           reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    R_PAR           reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)
    COMMA           reduce using rule 36 (binary_operation -> expression MULTIPLY expression .)

  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MULTIPLY        [ shift and go to state 28 ]
  ! DIVIDE          [ shift and go to state 29 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 59

    (37) binary_operation -> expression DIVIDE expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    PLUS            reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    MINUS           reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    MULTIPLY        reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    MODULO          reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    EQ              reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    NEQ             reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    LT              reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    GT              reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    LEQ             reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    GEQ             reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    OR              reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    AND             reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    L_PAR           reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    R_PAR           reduce using rule 37 (binary_operation -> expression DIVIDE expression .)
    COMMA           reduce using rule 37 (binary_operation -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MULTIPLY        [ shift and go to state 28 ]
  ! DIVIDE          [ shift and go to state 29 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 60

    (38) binary_operation -> expression MODULO expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 38 (binary_operation -> expression MODULO expression .)
    R_PAR           reduce using rule 38 (binary_operation -> expression MODULO expression .)
    COMMA           reduce using rule 38 (binary_operation -> expression MODULO expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]
  ! MINUS           [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]
  ! MULTIPLY        [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]
  ! DIVIDE          [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]
  ! MODULO          [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]
  ! EQ              [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]
  ! NEQ             [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]
  ! LT              [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]
  ! GT              [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]
  ! LEQ             [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]
  ! GEQ             [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]
  ! OR              [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]
  ! AND             [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]
  ! L_PAR           [ reduce using rule 38 (binary_operation -> expression MODULO expression .) ]


state 61

    (39) binary_operation -> expression EQ expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 39 (binary_operation -> expression EQ expression .)
    R_PAR           reduce using rule 39 (binary_operation -> expression EQ expression .)
    COMMA           reduce using rule 39 (binary_operation -> expression EQ expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]
  ! MULTIPLY        [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]
  ! MODULO          [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]
  ! EQ              [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]
  ! NEQ             [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]
  ! LT              [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]
  ! GT              [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]
  ! LEQ             [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]
  ! GEQ             [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]
  ! OR              [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]
  ! AND             [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]
  ! L_PAR           [ reduce using rule 39 (binary_operation -> expression EQ expression .) ]


state 62

    (40) binary_operation -> expression NEQ expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 40 (binary_operation -> expression NEQ expression .)
    R_PAR           reduce using rule 40 (binary_operation -> expression NEQ expression .)
    COMMA           reduce using rule 40 (binary_operation -> expression NEQ expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]
  ! MINUS           [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]
  ! MULTIPLY        [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]
  ! DIVIDE          [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]
  ! MODULO          [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]
  ! EQ              [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]
  ! NEQ             [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]
  ! LT              [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]
  ! GT              [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]
  ! LEQ             [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]
  ! GEQ             [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]
  ! OR              [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]
  ! AND             [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]
  ! L_PAR           [ reduce using rule 40 (binary_operation -> expression NEQ expression .) ]


state 63

    (41) binary_operation -> expression LT expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 41 (binary_operation -> expression LT expression .)
    R_PAR           reduce using rule 41 (binary_operation -> expression LT expression .)
    COMMA           reduce using rule 41 (binary_operation -> expression LT expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 41 (binary_operation -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 41 (binary_operation -> expression LT expression .) ]
  ! MULTIPLY        [ reduce using rule 41 (binary_operation -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 41 (binary_operation -> expression LT expression .) ]
  ! MODULO          [ reduce using rule 41 (binary_operation -> expression LT expression .) ]
  ! EQ              [ reduce using rule 41 (binary_operation -> expression LT expression .) ]
  ! NEQ             [ reduce using rule 41 (binary_operation -> expression LT expression .) ]
  ! LT              [ reduce using rule 41 (binary_operation -> expression LT expression .) ]
  ! GT              [ reduce using rule 41 (binary_operation -> expression LT expression .) ]
  ! LEQ             [ reduce using rule 41 (binary_operation -> expression LT expression .) ]
  ! GEQ             [ reduce using rule 41 (binary_operation -> expression LT expression .) ]
  ! OR              [ reduce using rule 41 (binary_operation -> expression LT expression .) ]
  ! AND             [ reduce using rule 41 (binary_operation -> expression LT expression .) ]
  ! L_PAR           [ reduce using rule 41 (binary_operation -> expression LT expression .) ]


state 64

    (42) binary_operation -> expression GT expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 42 (binary_operation -> expression GT expression .)
    R_PAR           reduce using rule 42 (binary_operation -> expression GT expression .)
    COMMA           reduce using rule 42 (binary_operation -> expression GT expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 42 (binary_operation -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 42 (binary_operation -> expression GT expression .) ]
  ! MULTIPLY        [ reduce using rule 42 (binary_operation -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 42 (binary_operation -> expression GT expression .) ]
  ! MODULO          [ reduce using rule 42 (binary_operation -> expression GT expression .) ]
  ! EQ              [ reduce using rule 42 (binary_operation -> expression GT expression .) ]
  ! NEQ             [ reduce using rule 42 (binary_operation -> expression GT expression .) ]
  ! LT              [ reduce using rule 42 (binary_operation -> expression GT expression .) ]
  ! GT              [ reduce using rule 42 (binary_operation -> expression GT expression .) ]
  ! LEQ             [ reduce using rule 42 (binary_operation -> expression GT expression .) ]
  ! GEQ             [ reduce using rule 42 (binary_operation -> expression GT expression .) ]
  ! OR              [ reduce using rule 42 (binary_operation -> expression GT expression .) ]
  ! AND             [ reduce using rule 42 (binary_operation -> expression GT expression .) ]
  ! L_PAR           [ reduce using rule 42 (binary_operation -> expression GT expression .) ]


state 65

    (43) binary_operation -> expression LEQ expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 43 (binary_operation -> expression LEQ expression .)
    R_PAR           reduce using rule 43 (binary_operation -> expression LEQ expression .)
    COMMA           reduce using rule 43 (binary_operation -> expression LEQ expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]
  ! MINUS           [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]
  ! MULTIPLY        [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]
  ! DIVIDE          [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]
  ! MODULO          [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]
  ! EQ              [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]
  ! NEQ             [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]
  ! LT              [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]
  ! GT              [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]
  ! LEQ             [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]
  ! GEQ             [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]
  ! OR              [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]
  ! AND             [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]
  ! L_PAR           [ reduce using rule 43 (binary_operation -> expression LEQ expression .) ]


state 66

    (44) binary_operation -> expression GEQ expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 44 (binary_operation -> expression GEQ expression .)
    R_PAR           reduce using rule 44 (binary_operation -> expression GEQ expression .)
    COMMA           reduce using rule 44 (binary_operation -> expression GEQ expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]
  ! MINUS           [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]
  ! MULTIPLY        [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]
  ! DIVIDE          [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]
  ! MODULO          [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]
  ! EQ              [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]
  ! NEQ             [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]
  ! LT              [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]
  ! GT              [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]
  ! LEQ             [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]
  ! GEQ             [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]
  ! OR              [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]
  ! AND             [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]
  ! L_PAR           [ reduce using rule 44 (binary_operation -> expression GEQ expression .) ]


state 67

    (45) binary_operation -> expression OR expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 45 (binary_operation -> expression OR expression .)
    R_PAR           reduce using rule 45 (binary_operation -> expression OR expression .)
    COMMA           reduce using rule 45 (binary_operation -> expression OR expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 45 (binary_operation -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 45 (binary_operation -> expression OR expression .) ]
  ! MULTIPLY        [ reduce using rule 45 (binary_operation -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 45 (binary_operation -> expression OR expression .) ]
  ! MODULO          [ reduce using rule 45 (binary_operation -> expression OR expression .) ]
  ! EQ              [ reduce using rule 45 (binary_operation -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 45 (binary_operation -> expression OR expression .) ]
  ! LT              [ reduce using rule 45 (binary_operation -> expression OR expression .) ]
  ! GT              [ reduce using rule 45 (binary_operation -> expression OR expression .) ]
  ! LEQ             [ reduce using rule 45 (binary_operation -> expression OR expression .) ]
  ! GEQ             [ reduce using rule 45 (binary_operation -> expression OR expression .) ]
  ! OR              [ reduce using rule 45 (binary_operation -> expression OR expression .) ]
  ! AND             [ reduce using rule 45 (binary_operation -> expression OR expression .) ]
  ! L_PAR           [ reduce using rule 45 (binary_operation -> expression OR expression .) ]


state 68

    (46) binary_operation -> expression AND expression .
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 46 (binary_operation -> expression AND expression .)
    R_PAR           reduce using rule 46 (binary_operation -> expression AND expression .)
    COMMA           reduce using rule 46 (binary_operation -> expression AND expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 46 (binary_operation -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 46 (binary_operation -> expression AND expression .) ]
  ! MULTIPLY        [ reduce using rule 46 (binary_operation -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 46 (binary_operation -> expression AND expression .) ]
  ! MODULO          [ reduce using rule 46 (binary_operation -> expression AND expression .) ]
  ! EQ              [ reduce using rule 46 (binary_operation -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 46 (binary_operation -> expression AND expression .) ]
  ! LT              [ reduce using rule 46 (binary_operation -> expression AND expression .) ]
  ! GT              [ reduce using rule 46 (binary_operation -> expression AND expression .) ]
  ! LEQ             [ reduce using rule 46 (binary_operation -> expression AND expression .) ]
  ! GEQ             [ reduce using rule 46 (binary_operation -> expression AND expression .) ]
  ! OR              [ reduce using rule 46 (binary_operation -> expression AND expression .) ]
  ! AND             [ reduce using rule 46 (binary_operation -> expression AND expression .) ]
  ! L_PAR           [ reduce using rule 46 (binary_operation -> expression AND expression .) ]


state 69

    (50) arg_list -> expression .
    (51) arg_list -> expression . COMMA arg_list
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    R_PAR           reduce using rule 50 (arg_list -> expression .)
    COMMA           shift and go to state 86
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 70

    (56) function_call -> expression L_PAR R_PAR .

    SEMI            reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    PLUS            reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    MINUS           reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    MULTIPLY        reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    DIVIDE          reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    MODULO          reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    EQ              reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    NEQ             reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    LT              reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    GT              reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    LEQ             reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    GEQ             reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    OR              reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    AND             reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    L_PAR           reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    R_PAR           reduce using rule 56 (function_call -> expression L_PAR R_PAR .)
    COMMA           reduce using rule 56 (function_call -> expression L_PAR R_PAR .)


state 71

    (57) function_call -> expression L_PAR arg_list . R_PAR

    R_PAR           shift and go to state 87


state 72

    (13) statement -> IDEN ASSIGN expression . SEMI
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 88
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 73

    (14) statement -> LET IDEN SEMI .

    IDEN            reduce using rule 14 (statement -> LET IDEN SEMI .)
    LET             reduce using rule 14 (statement -> LET IDEN SEMI .)
    RETURN          reduce using rule 14 (statement -> LET IDEN SEMI .)
    IF              reduce using rule 14 (statement -> LET IDEN SEMI .)
    WHILE           reduce using rule 14 (statement -> LET IDEN SEMI .)
    L_BRC           reduce using rule 14 (statement -> LET IDEN SEMI .)
    BREAK           reduce using rule 14 (statement -> LET IDEN SEMI .)
    CONTINUE        reduce using rule 14 (statement -> LET IDEN SEMI .)
    L_PAR           reduce using rule 14 (statement -> LET IDEN SEMI .)
    NUM_LIT         reduce using rule 14 (statement -> LET IDEN SEMI .)
    BOOL_LIT        reduce using rule 14 (statement -> LET IDEN SEMI .)
    STR_LIT         reduce using rule 14 (statement -> LET IDEN SEMI .)
    PLUS            reduce using rule 14 (statement -> LET IDEN SEMI .)
    MINUS           reduce using rule 14 (statement -> LET IDEN SEMI .)
    NOT             reduce using rule 14 (statement -> LET IDEN SEMI .)
    $end            reduce using rule 14 (statement -> LET IDEN SEMI .)
    R_BRC           reduce using rule 14 (statement -> LET IDEN SEMI .)
    ELSE            reduce using rule 14 (statement -> LET IDEN SEMI .)


state 74

    (15) statement -> LET IDEN COLON . type SEMI
    (17) statement -> LET IDEN COLON . type ASSIGN expression SEMI
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . type ARROW type
    (7) type -> . L_PAR typelist R_PAR

    NUMBER          shift and go to state 90
    BOOL            shift and go to state 91
    STRING          shift and go to state 92
    ANY             shift and go to state 93
    L_PAR           shift and go to state 94

    type                           shift and go to state 89

state 75

    (16) statement -> LET IDEN ASSIGN . expression SEMI
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 95
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 76

    (18) statement -> RETURN expression SEMI .

    IDEN            reduce using rule 18 (statement -> RETURN expression SEMI .)
    LET             reduce using rule 18 (statement -> RETURN expression SEMI .)
    RETURN          reduce using rule 18 (statement -> RETURN expression SEMI .)
    IF              reduce using rule 18 (statement -> RETURN expression SEMI .)
    WHILE           reduce using rule 18 (statement -> RETURN expression SEMI .)
    L_BRC           reduce using rule 18 (statement -> RETURN expression SEMI .)
    BREAK           reduce using rule 18 (statement -> RETURN expression SEMI .)
    CONTINUE        reduce using rule 18 (statement -> RETURN expression SEMI .)
    L_PAR           reduce using rule 18 (statement -> RETURN expression SEMI .)
    NUM_LIT         reduce using rule 18 (statement -> RETURN expression SEMI .)
    BOOL_LIT        reduce using rule 18 (statement -> RETURN expression SEMI .)
    STR_LIT         reduce using rule 18 (statement -> RETURN expression SEMI .)
    PLUS            reduce using rule 18 (statement -> RETURN expression SEMI .)
    MINUS           reduce using rule 18 (statement -> RETURN expression SEMI .)
    NOT             reduce using rule 18 (statement -> RETURN expression SEMI .)
    $end            reduce using rule 18 (statement -> RETURN expression SEMI .)
    R_BRC           reduce using rule 18 (statement -> RETURN expression SEMI .)
    ELSE            reduce using rule 18 (statement -> RETURN expression SEMI .)


state 77

    (19) statement -> IF L_PAR expression . R_PAR statement ELSE statement
    (20) statement -> IF L_PAR expression . R_PAR statement
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    R_PAR           shift and go to state 96
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 78

    (27) expression -> L_PAR expression R_PAR .

    SEMI            reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    PLUS            reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    MINUS           reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    MULTIPLY        reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    DIVIDE          reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    MODULO          reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    EQ              reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    NEQ             reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    LT              reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    GT              reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    LEQ             reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    GEQ             reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    OR              reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    AND             reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    L_PAR           reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    R_PAR           reduce using rule 27 (expression -> L_PAR expression R_PAR .)
    COMMA           reduce using rule 27 (expression -> L_PAR expression R_PAR .)


state 79

    (58) lambda -> L_PAR R_PAR ARROW . L_BRC block R_BRC

    L_BRC           shift and go to state 97


state 80

    (59) lambda -> L_PAR param_list R_PAR . ARROW L_BRC block R_BRC

    ARROW           shift and go to state 98


state 81

    (60) lambda -> L_PAR IDEN R_PAR . ARROW L_BRC block R_BRC

    ARROW           shift and go to state 99


state 82

    (52) param_list -> IDEN COMMA . param_list
    (52) param_list -> . IDEN COMMA param_list
    (53) param_list -> . IDEN COLON type COMMA param_list
    (54) param_list -> . IDEN
    (55) param_list -> . IDEN COLON type

    IDEN            shift and go to state 100

    param_list                     shift and go to state 101

state 83

    (53) param_list -> IDEN COLON . type COMMA param_list
    (55) param_list -> IDEN COLON . type
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . type ARROW type
    (7) type -> . L_PAR typelist R_PAR

    NUMBER          shift and go to state 90
    BOOL            shift and go to state 91
    STRING          shift and go to state 92
    ANY             shift and go to state 93
    L_PAR           shift and go to state 94

    type                           shift and go to state 102

state 84

    (21) statement -> WHILE L_PAR expression . R_PAR statement
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    R_PAR           shift and go to state 103
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 85

    (22) statement -> L_BRC block R_BRC .

    IDEN            reduce using rule 22 (statement -> L_BRC block R_BRC .)
    LET             reduce using rule 22 (statement -> L_BRC block R_BRC .)
    RETURN          reduce using rule 22 (statement -> L_BRC block R_BRC .)
    IF              reduce using rule 22 (statement -> L_BRC block R_BRC .)
    WHILE           reduce using rule 22 (statement -> L_BRC block R_BRC .)
    L_BRC           reduce using rule 22 (statement -> L_BRC block R_BRC .)
    BREAK           reduce using rule 22 (statement -> L_BRC block R_BRC .)
    CONTINUE        reduce using rule 22 (statement -> L_BRC block R_BRC .)
    L_PAR           reduce using rule 22 (statement -> L_BRC block R_BRC .)
    NUM_LIT         reduce using rule 22 (statement -> L_BRC block R_BRC .)
    BOOL_LIT        reduce using rule 22 (statement -> L_BRC block R_BRC .)
    STR_LIT         reduce using rule 22 (statement -> L_BRC block R_BRC .)
    PLUS            reduce using rule 22 (statement -> L_BRC block R_BRC .)
    MINUS           reduce using rule 22 (statement -> L_BRC block R_BRC .)
    NOT             reduce using rule 22 (statement -> L_BRC block R_BRC .)
    $end            reduce using rule 22 (statement -> L_BRC block R_BRC .)
    R_BRC           reduce using rule 22 (statement -> L_BRC block R_BRC .)
    ELSE            reduce using rule 22 (statement -> L_BRC block R_BRC .)


state 86

    (51) arg_list -> expression COMMA . arg_list
    (50) arg_list -> . expression
    (51) arg_list -> . expression COMMA arg_list
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 69
    arg_list                       shift and go to state 104
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 87

    (57) function_call -> expression L_PAR arg_list R_PAR .

    SEMI            reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    PLUS            reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    MINUS           reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    MULTIPLY        reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    DIVIDE          reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    MODULO          reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    EQ              reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    NEQ             reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    LT              reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    GT              reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    LEQ             reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    GEQ             reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    OR              reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    AND             reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    L_PAR           reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    R_PAR           reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)
    COMMA           reduce using rule 57 (function_call -> expression L_PAR arg_list R_PAR .)


state 88

    (13) statement -> IDEN ASSIGN expression SEMI .

    IDEN            reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    LET             reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    RETURN          reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    IF              reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    WHILE           reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    L_BRC           reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    BREAK           reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    CONTINUE        reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    L_PAR           reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    NUM_LIT         reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    BOOL_LIT        reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    STR_LIT         reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    PLUS            reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    MINUS           reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    NOT             reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    $end            reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    R_BRC           reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)
    ELSE            reduce using rule 13 (statement -> IDEN ASSIGN expression SEMI .)


state 89

    (15) statement -> LET IDEN COLON type . SEMI
    (17) statement -> LET IDEN COLON type . ASSIGN expression SEMI
    (6) type -> type . ARROW type

    SEMI            shift and go to state 105
    ASSIGN          shift and go to state 106
    ARROW           shift and go to state 107


state 90

    (2) type -> NUMBER .

    SEMI            reduce using rule 2 (type -> NUMBER .)
    ASSIGN          reduce using rule 2 (type -> NUMBER .)
    ARROW           reduce using rule 2 (type -> NUMBER .)
    COMMA           reduce using rule 2 (type -> NUMBER .)
    R_PAR           reduce using rule 2 (type -> NUMBER .)


state 91

    (3) type -> BOOL .

    SEMI            reduce using rule 3 (type -> BOOL .)
    ASSIGN          reduce using rule 3 (type -> BOOL .)
    ARROW           reduce using rule 3 (type -> BOOL .)
    COMMA           reduce using rule 3 (type -> BOOL .)
    R_PAR           reduce using rule 3 (type -> BOOL .)


state 92

    (4) type -> STRING .

    SEMI            reduce using rule 4 (type -> STRING .)
    ASSIGN          reduce using rule 4 (type -> STRING .)
    ARROW           reduce using rule 4 (type -> STRING .)
    COMMA           reduce using rule 4 (type -> STRING .)
    R_PAR           reduce using rule 4 (type -> STRING .)


state 93

    (5) type -> ANY .

    SEMI            reduce using rule 5 (type -> ANY .)
    ASSIGN          reduce using rule 5 (type -> ANY .)
    ARROW           reduce using rule 5 (type -> ANY .)
    COMMA           reduce using rule 5 (type -> ANY .)
    R_PAR           reduce using rule 5 (type -> ANY .)


state 94

    (7) type -> L_PAR . typelist R_PAR
    (8) typelist -> . type COMMA typelist
    (9) typelist -> . type
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . type ARROW type
    (7) type -> . L_PAR typelist R_PAR

    NUMBER          shift and go to state 90
    BOOL            shift and go to state 91
    STRING          shift and go to state 92
    ANY             shift and go to state 93
    L_PAR           shift and go to state 94

    typelist                       shift and go to state 108
    type                           shift and go to state 109

state 95

    (16) statement -> LET IDEN ASSIGN expression . SEMI
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 110
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 96

    (19) statement -> IF L_PAR expression R_PAR . statement ELSE statement
    (20) statement -> IF L_PAR expression R_PAR . statement
    (12) statement -> . expression SEMI
    (13) statement -> . IDEN ASSIGN expression SEMI
    (14) statement -> . LET IDEN SEMI
    (15) statement -> . LET IDEN COLON type SEMI
    (16) statement -> . LET IDEN ASSIGN expression SEMI
    (17) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (18) statement -> . RETURN expression SEMI
    (19) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (20) statement -> . IF L_PAR expression R_PAR statement
    (21) statement -> . WHILE L_PAR expression R_PAR statement
    (22) statement -> . L_BRC block R_BRC
    (23) statement -> . BREAK SEMI
    (24) statement -> . CONTINUE SEMI
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 4
    statement                      shift and go to state 111
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 97

    (58) lambda -> L_PAR R_PAR ARROW L_BRC . block R_BRC
    (10) block -> . statement
    (11) block -> . statement block
    (12) statement -> . expression SEMI
    (13) statement -> . IDEN ASSIGN expression SEMI
    (14) statement -> . LET IDEN SEMI
    (15) statement -> . LET IDEN COLON type SEMI
    (16) statement -> . LET IDEN ASSIGN expression SEMI
    (17) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (18) statement -> . RETURN expression SEMI
    (19) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (20) statement -> . IF L_PAR expression R_PAR statement
    (21) statement -> . WHILE L_PAR expression R_PAR statement
    (22) statement -> . L_BRC block R_BRC
    (23) statement -> . BREAK SEMI
    (24) statement -> . CONTINUE SEMI
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    block                          shift and go to state 112
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 98

    (59) lambda -> L_PAR param_list R_PAR ARROW . L_BRC block R_BRC

    L_BRC           shift and go to state 113


state 99

    (60) lambda -> L_PAR IDEN R_PAR ARROW . L_BRC block R_BRC

    L_BRC           shift and go to state 114


state 100

    (52) param_list -> IDEN . COMMA param_list
    (53) param_list -> IDEN . COLON type COMMA param_list
    (54) param_list -> IDEN .
    (55) param_list -> IDEN . COLON type

    COMMA           shift and go to state 82
    COLON           shift and go to state 83
    R_PAR           reduce using rule 54 (param_list -> IDEN .)


state 101

    (52) param_list -> IDEN COMMA param_list .

    R_PAR           reduce using rule 52 (param_list -> IDEN COMMA param_list .)


state 102

    (53) param_list -> IDEN COLON type . COMMA param_list
    (55) param_list -> IDEN COLON type .
    (6) type -> type . ARROW type

    COMMA           shift and go to state 115
    R_PAR           reduce using rule 55 (param_list -> IDEN COLON type .)
    ARROW           shift and go to state 107


state 103

    (21) statement -> WHILE L_PAR expression R_PAR . statement
    (12) statement -> . expression SEMI
    (13) statement -> . IDEN ASSIGN expression SEMI
    (14) statement -> . LET IDEN SEMI
    (15) statement -> . LET IDEN COLON type SEMI
    (16) statement -> . LET IDEN ASSIGN expression SEMI
    (17) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (18) statement -> . RETURN expression SEMI
    (19) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (20) statement -> . IF L_PAR expression R_PAR statement
    (21) statement -> . WHILE L_PAR expression R_PAR statement
    (22) statement -> . L_BRC block R_BRC
    (23) statement -> . BREAK SEMI
    (24) statement -> . CONTINUE SEMI
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 4
    statement                      shift and go to state 116
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 104

    (51) arg_list -> expression COMMA arg_list .

    R_PAR           reduce using rule 51 (arg_list -> expression COMMA arg_list .)


state 105

    (15) statement -> LET IDEN COLON type SEMI .

    IDEN            reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    LET             reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    RETURN          reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    IF              reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    WHILE           reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    L_BRC           reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    BREAK           reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    CONTINUE        reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    L_PAR           reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    NUM_LIT         reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    BOOL_LIT        reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    STR_LIT         reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    PLUS            reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    MINUS           reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    NOT             reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    $end            reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    R_BRC           reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)
    ELSE            reduce using rule 15 (statement -> LET IDEN COLON type SEMI .)


state 106

    (17) statement -> LET IDEN COLON type ASSIGN . expression SEMI
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 117
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 107

    (6) type -> type ARROW . type
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . type ARROW type
    (7) type -> . L_PAR typelist R_PAR

    NUMBER          shift and go to state 90
    BOOL            shift and go to state 91
    STRING          shift and go to state 92
    ANY             shift and go to state 93
    L_PAR           shift and go to state 94

    type                           shift and go to state 118

state 108

    (7) type -> L_PAR typelist . R_PAR

    R_PAR           shift and go to state 119


state 109

    (8) typelist -> type . COMMA typelist
    (9) typelist -> type .
    (6) type -> type . ARROW type

    COMMA           shift and go to state 120
    R_PAR           reduce using rule 9 (typelist -> type .)
    ARROW           shift and go to state 107


state 110

    (16) statement -> LET IDEN ASSIGN expression SEMI .

    IDEN            reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    LET             reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    RETURN          reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    IF              reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    WHILE           reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    L_BRC           reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    BREAK           reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    CONTINUE        reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    L_PAR           reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    NUM_LIT         reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    BOOL_LIT        reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    STR_LIT         reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    PLUS            reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    MINUS           reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    NOT             reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    $end            reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    R_BRC           reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)
    ELSE            reduce using rule 16 (statement -> LET IDEN ASSIGN expression SEMI .)


state 111

    (19) statement -> IF L_PAR expression R_PAR statement . ELSE statement
    (20) statement -> IF L_PAR expression R_PAR statement .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 121
    IDEN            reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    LET             reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    RETURN          reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    IF              reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    WHILE           reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    L_BRC           reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    BREAK           reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    CONTINUE        reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    L_PAR           reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    NUM_LIT         reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    BOOL_LIT        reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    STR_LIT         reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    PLUS            reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    MINUS           reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    NOT             reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    $end            reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)
    R_BRC           reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .)

  ! ELSE            [ reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement .) ]


state 112

    (58) lambda -> L_PAR R_PAR ARROW L_BRC block . R_BRC

    R_BRC           shift and go to state 122


state 113

    (59) lambda -> L_PAR param_list R_PAR ARROW L_BRC . block R_BRC
    (10) block -> . statement
    (11) block -> . statement block
    (12) statement -> . expression SEMI
    (13) statement -> . IDEN ASSIGN expression SEMI
    (14) statement -> . LET IDEN SEMI
    (15) statement -> . LET IDEN COLON type SEMI
    (16) statement -> . LET IDEN ASSIGN expression SEMI
    (17) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (18) statement -> . RETURN expression SEMI
    (19) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (20) statement -> . IF L_PAR expression R_PAR statement
    (21) statement -> . WHILE L_PAR expression R_PAR statement
    (22) statement -> . L_BRC block R_BRC
    (23) statement -> . BREAK SEMI
    (24) statement -> . CONTINUE SEMI
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    block                          shift and go to state 123
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 114

    (60) lambda -> L_PAR IDEN R_PAR ARROW L_BRC . block R_BRC
    (10) block -> . statement
    (11) block -> . statement block
    (12) statement -> . expression SEMI
    (13) statement -> . IDEN ASSIGN expression SEMI
    (14) statement -> . LET IDEN SEMI
    (15) statement -> . LET IDEN COLON type SEMI
    (16) statement -> . LET IDEN ASSIGN expression SEMI
    (17) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (18) statement -> . RETURN expression SEMI
    (19) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (20) statement -> . IF L_PAR expression R_PAR statement
    (21) statement -> . WHILE L_PAR expression R_PAR statement
    (22) statement -> . L_BRC block R_BRC
    (23) statement -> . BREAK SEMI
    (24) statement -> . CONTINUE SEMI
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    block                          shift and go to state 124
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 115

    (53) param_list -> IDEN COLON type COMMA . param_list
    (52) param_list -> . IDEN COMMA param_list
    (53) param_list -> . IDEN COLON type COMMA param_list
    (54) param_list -> . IDEN
    (55) param_list -> . IDEN COLON type

    IDEN            shift and go to state 100

    param_list                     shift and go to state 125

state 116

    (21) statement -> WHILE L_PAR expression R_PAR statement .

    IDEN            reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    LET             reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    RETURN          reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    IF              reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    WHILE           reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    L_BRC           reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    BREAK           reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    CONTINUE        reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    L_PAR           reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    NUM_LIT         reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    BOOL_LIT        reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    STR_LIT         reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    PLUS            reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    MINUS           reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    NOT             reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    $end            reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    R_BRC           reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)
    ELSE            reduce using rule 21 (statement -> WHILE L_PAR expression R_PAR statement .)


state 117

    (17) statement -> LET IDEN COLON type ASSIGN expression . SEMI
    (34) binary_operation -> expression . PLUS expression
    (35) binary_operation -> expression . MINUS expression
    (36) binary_operation -> expression . MULTIPLY expression
    (37) binary_operation -> expression . DIVIDE expression
    (38) binary_operation -> expression . MODULO expression
    (39) binary_operation -> expression . EQ expression
    (40) binary_operation -> expression . NEQ expression
    (41) binary_operation -> expression . LT expression
    (42) binary_operation -> expression . GT expression
    (43) binary_operation -> expression . LEQ expression
    (44) binary_operation -> expression . GEQ expression
    (45) binary_operation -> expression . OR expression
    (46) binary_operation -> expression . AND expression
    (56) function_call -> expression . L_PAR R_PAR
    (57) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 126
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 118

    (6) type -> type ARROW type .
    (6) type -> type . ARROW type

  ! shift/reduce conflict for ARROW resolved as shift
    SEMI            reduce using rule 6 (type -> type ARROW type .)
    ASSIGN          reduce using rule 6 (type -> type ARROW type .)
    COMMA           reduce using rule 6 (type -> type ARROW type .)
    R_PAR           reduce using rule 6 (type -> type ARROW type .)
    ARROW           shift and go to state 107

  ! ARROW           [ reduce using rule 6 (type -> type ARROW type .) ]


state 119

    (7) type -> L_PAR typelist R_PAR .

    SEMI            reduce using rule 7 (type -> L_PAR typelist R_PAR .)
    ASSIGN          reduce using rule 7 (type -> L_PAR typelist R_PAR .)
    ARROW           reduce using rule 7 (type -> L_PAR typelist R_PAR .)
    COMMA           reduce using rule 7 (type -> L_PAR typelist R_PAR .)
    R_PAR           reduce using rule 7 (type -> L_PAR typelist R_PAR .)


state 120

    (8) typelist -> type COMMA . typelist
    (8) typelist -> . type COMMA typelist
    (9) typelist -> . type
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . type ARROW type
    (7) type -> . L_PAR typelist R_PAR

    NUMBER          shift and go to state 90
    BOOL            shift and go to state 91
    STRING          shift and go to state 92
    ANY             shift and go to state 93
    L_PAR           shift and go to state 94

    type                           shift and go to state 109
    typelist                       shift and go to state 127

state 121

    (19) statement -> IF L_PAR expression R_PAR statement ELSE . statement
    (12) statement -> . expression SEMI
    (13) statement -> . IDEN ASSIGN expression SEMI
    (14) statement -> . LET IDEN SEMI
    (15) statement -> . LET IDEN COLON type SEMI
    (16) statement -> . LET IDEN ASSIGN expression SEMI
    (17) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (18) statement -> . RETURN expression SEMI
    (19) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (20) statement -> . IF L_PAR expression R_PAR statement
    (21) statement -> . WHILE L_PAR expression R_PAR statement
    (22) statement -> . L_BRC block R_BRC
    (23) statement -> . BREAK SEMI
    (24) statement -> . CONTINUE SEMI
    (25) expression -> . binary_operation
    (26) expression -> . unary_operation
    (27) expression -> . L_PAR expression R_PAR
    (28) expression -> . NUM_LIT
    (29) expression -> . BOOL_LIT
    (30) expression -> . STR_LIT
    (31) expression -> . function_call
    (32) expression -> . lambda
    (33) expression -> . IDEN
    (34) binary_operation -> . expression PLUS expression
    (35) binary_operation -> . expression MINUS expression
    (36) binary_operation -> . expression MULTIPLY expression
    (37) binary_operation -> . expression DIVIDE expression
    (38) binary_operation -> . expression MODULO expression
    (39) binary_operation -> . expression EQ expression
    (40) binary_operation -> . expression NEQ expression
    (41) binary_operation -> . expression LT expression
    (42) binary_operation -> . expression GT expression
    (43) binary_operation -> . expression LEQ expression
    (44) binary_operation -> . expression GEQ expression
    (45) binary_operation -> . expression OR expression
    (46) binary_operation -> . expression AND expression
    (47) unary_operation -> . PLUS expression
    (48) unary_operation -> . MINUS expression
    (49) unary_operation -> . NOT expression
    (56) function_call -> . expression L_PAR R_PAR
    (57) function_call -> . expression L_PAR arg_list R_PAR
    (58) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (59) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (60) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 4
    statement                      shift and go to state 128
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 122

    (58) lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .

    SEMI            reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    PLUS            reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    MINUS           reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    MULTIPLY        reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    DIVIDE          reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    MODULO          reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    EQ              reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    NEQ             reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    LT              reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    GT              reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    LEQ             reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    GEQ             reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    OR              reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    AND             reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    L_PAR           reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    R_PAR           reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    COMMA           reduce using rule 58 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)


state 123

    (59) lambda -> L_PAR param_list R_PAR ARROW L_BRC block . R_BRC

    R_BRC           shift and go to state 129


state 124

    (60) lambda -> L_PAR IDEN R_PAR ARROW L_BRC block . R_BRC

    R_BRC           shift and go to state 130


state 125

    (53) param_list -> IDEN COLON type COMMA param_list .

    R_PAR           reduce using rule 53 (param_list -> IDEN COLON type COMMA param_list .)


state 126

    (17) statement -> LET IDEN COLON type ASSIGN expression SEMI .

    IDEN            reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    LET             reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    RETURN          reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    IF              reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    WHILE           reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    L_BRC           reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    BREAK           reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    CONTINUE        reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    L_PAR           reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    NUM_LIT         reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    BOOL_LIT        reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    STR_LIT         reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    PLUS            reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    MINUS           reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    NOT             reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    $end            reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    R_BRC           reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    ELSE            reduce using rule 17 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)


state 127

    (8) typelist -> type COMMA typelist .

    R_PAR           reduce using rule 8 (typelist -> type COMMA typelist .)


state 128

    (19) statement -> IF L_PAR expression R_PAR statement ELSE statement .

    IDEN            reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    LET             reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    RETURN          reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    IF              reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    WHILE           reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    L_BRC           reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    BREAK           reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    CONTINUE        reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    L_PAR           reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    NUM_LIT         reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    BOOL_LIT        reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    STR_LIT         reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    PLUS            reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    MINUS           reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    NOT             reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    $end            reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    R_BRC           reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    ELSE            reduce using rule 19 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)


state 129

    (59) lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .

    SEMI            reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    PLUS            reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    MINUS           reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    MULTIPLY        reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    DIVIDE          reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    MODULO          reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    EQ              reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    NEQ             reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    LT              reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    GT              reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    LEQ             reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    GEQ             reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    OR              reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    AND             reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    L_PAR           reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    R_PAR           reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    COMMA           reduce using rule 59 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)


state 130

    (60) lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .

    SEMI            reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    PLUS            reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    MINUS           reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    MULTIPLY        reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    DIVIDE          reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    MODULO          reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    EQ              reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    NEQ             reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    LT              reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    GT              reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    LEQ             reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    GEQ             reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    OR              reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    AND             reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    L_PAR           reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    R_PAR           reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    COMMA           reduce using rule 60 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for R_PAR in state 48 resolved as shift
WARNING: shift/reduce conflict for R_PAR in state 48 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 60 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 60 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 60 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 60 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 60 resolved as shift
WARNING: shift/reduce conflict for EQ in state 60 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 60 resolved as shift
WARNING: shift/reduce conflict for LT in state 60 resolved as shift
WARNING: shift/reduce conflict for GT in state 60 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 60 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 60 resolved as shift
WARNING: shift/reduce conflict for OR in state 60 resolved as shift
WARNING: shift/reduce conflict for AND in state 60 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 60 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 61 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 61 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 61 resolved as shift
WARNING: shift/reduce conflict for EQ in state 61 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 61 resolved as shift
WARNING: shift/reduce conflict for LT in state 61 resolved as shift
WARNING: shift/reduce conflict for GT in state 61 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 61 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 61 resolved as shift
WARNING: shift/reduce conflict for OR in state 61 resolved as shift
WARNING: shift/reduce conflict for AND in state 61 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 61 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 62 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 62 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 62 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 62 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 62 resolved as shift
WARNING: shift/reduce conflict for EQ in state 62 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 62 resolved as shift
WARNING: shift/reduce conflict for LT in state 62 resolved as shift
WARNING: shift/reduce conflict for GT in state 62 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 62 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 62 resolved as shift
WARNING: shift/reduce conflict for OR in state 62 resolved as shift
WARNING: shift/reduce conflict for AND in state 62 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 62 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 63 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 63 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 63 resolved as shift
WARNING: shift/reduce conflict for EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 63 resolved as shift
WARNING: shift/reduce conflict for LT in state 63 resolved as shift
WARNING: shift/reduce conflict for GT in state 63 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 63 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 63 resolved as shift
WARNING: shift/reduce conflict for OR in state 63 resolved as shift
WARNING: shift/reduce conflict for AND in state 63 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 63 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 64 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 64 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 64 resolved as shift
WARNING: shift/reduce conflict for EQ in state 64 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 64 resolved as shift
WARNING: shift/reduce conflict for LT in state 64 resolved as shift
WARNING: shift/reduce conflict for GT in state 64 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 64 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 64 resolved as shift
WARNING: shift/reduce conflict for OR in state 64 resolved as shift
WARNING: shift/reduce conflict for AND in state 64 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 65 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 65 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 65 resolved as shift
WARNING: shift/reduce conflict for EQ in state 65 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 65 resolved as shift
WARNING: shift/reduce conflict for LT in state 65 resolved as shift
WARNING: shift/reduce conflict for GT in state 65 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 65 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 65 resolved as shift
WARNING: shift/reduce conflict for OR in state 65 resolved as shift
WARNING: shift/reduce conflict for AND in state 65 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 65 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 66 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 66 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 66 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 66 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 66 resolved as shift
WARNING: shift/reduce conflict for EQ in state 66 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 66 resolved as shift
WARNING: shift/reduce conflict for LT in state 66 resolved as shift
WARNING: shift/reduce conflict for GT in state 66 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 66 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 66 resolved as shift
WARNING: shift/reduce conflict for OR in state 66 resolved as shift
WARNING: shift/reduce conflict for AND in state 66 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 66 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 67 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 67 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 67 resolved as shift
WARNING: shift/reduce conflict for EQ in state 67 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 67 resolved as shift
WARNING: shift/reduce conflict for LT in state 67 resolved as shift
WARNING: shift/reduce conflict for GT in state 67 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 67 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 67 resolved as shift
WARNING: shift/reduce conflict for OR in state 67 resolved as shift
WARNING: shift/reduce conflict for AND in state 67 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 67 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 68 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 68 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 68 resolved as shift
WARNING: shift/reduce conflict for EQ in state 68 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 68 resolved as shift
WARNING: shift/reduce conflict for LT in state 68 resolved as shift
WARNING: shift/reduce conflict for GT in state 68 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 68 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 68 resolved as shift
WARNING: shift/reduce conflict for OR in state 68 resolved as shift
WARNING: shift/reduce conflict for AND in state 68 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 68 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 111 resolved as shift
WARNING: shift/reduce conflict for ARROW in state 118 resolved as shift
