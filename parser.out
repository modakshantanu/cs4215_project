Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    MULTI_COMMENT
    SINGLE_COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     type -> NUMBER
Rule 3     type -> BOOL
Rule 4     type -> STRING
Rule 5     type -> ANY
Rule 6     type -> VOID
Rule 7     type -> type ARROW type
Rule 8     type -> L_PAR typelist R_PAR
Rule 9     typelist -> type COMMA typelist
Rule 10    typelist -> type
Rule 11    block -> statement
Rule 12    block -> statement block
Rule 13    statement -> expression SEMI
Rule 14    statement -> IDEN ASSIGN expression SEMI
Rule 15    statement -> LET IDEN SEMI
Rule 16    statement -> LET IDEN COLON type SEMI
Rule 17    statement -> LET IDEN ASSIGN expression SEMI
Rule 18    statement -> LET IDEN COLON type ASSIGN expression SEMI
Rule 19    statement -> RETURN expression SEMI
Rule 20    statement -> IF L_PAR expression R_PAR statement ELSE statement
Rule 21    statement -> IF L_PAR expression R_PAR statement
Rule 22    statement -> WHILE L_PAR expression R_PAR statement
Rule 23    statement -> L_BRC block R_BRC
Rule 24    statement -> BREAK SEMI
Rule 25    statement -> CONTINUE SEMI
Rule 26    expression -> binary_operation
Rule 27    expression -> unary_operation
Rule 28    expression -> L_PAR expression R_PAR
Rule 29    expression -> NUM_LIT
Rule 30    expression -> BOOL_LIT
Rule 31    expression -> STR_LIT
Rule 32    expression -> function_call
Rule 33    expression -> lambda
Rule 34    expression -> IDEN
Rule 35    expression -> L_BKT arg_list R_BKT
Rule 36    expression -> expression L_BKT expression R_BKT
Rule 37    binary_operation -> expression PLUS expression
Rule 38    binary_operation -> expression MINUS expression
Rule 39    binary_operation -> expression MULTIPLY expression
Rule 40    binary_operation -> expression DIVIDE expression
Rule 41    binary_operation -> expression MODULO expression
Rule 42    binary_operation -> expression EQ expression
Rule 43    binary_operation -> expression NEQ expression
Rule 44    binary_operation -> expression LT expression
Rule 45    binary_operation -> expression GT expression
Rule 46    binary_operation -> expression LEQ expression
Rule 47    binary_operation -> expression GEQ expression
Rule 48    binary_operation -> expression OR expression
Rule 49    binary_operation -> expression AND expression
Rule 50    unary_operation -> PLUS expression
Rule 51    unary_operation -> MINUS expression
Rule 52    unary_operation -> NOT expression
Rule 53    arg_list -> expression
Rule 54    arg_list -> expression COMMA arg_list
Rule 55    param_list -> IDEN COMMA param_list
Rule 56    param_list -> IDEN COLON type COMMA param_list
Rule 57    param_list -> IDEN
Rule 58    param_list -> IDEN COLON type
Rule 59    function_call -> expression L_PAR R_PAR
Rule 60    function_call -> expression L_PAR arg_list R_PAR
Rule 61    lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC
Rule 62    lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
Rule 63    lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
Rule 64    lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
Rule 65    lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC
Rule 66    lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

Terminals, with rules where they appear

AND                  : 49
ANY                  : 5
ARROW                : 7 61 62 63 64 65 66
ASSIGN               : 14 17 18
BOOL                 : 3
BOOL_LIT             : 30
BREAK                : 24
COLON                : 16 18 56 58 62 64 66
COMMA                : 9 54 55 56
CONTINUE             : 25
DIVIDE               : 40
ELSE                 : 20
EQ                   : 42
GEQ                  : 47
GT                   : 45
IDEN                 : 14 15 16 17 18 34 55 56 57 58 63 64
IF                   : 20 21
LEQ                  : 46
LET                  : 15 16 17 18
LT                   : 44
L_BKT                : 35 36
L_BRC                : 23 61 62 63 64 65 66
L_PAR                : 8 20 21 22 28 59 60 61 62 63 64 65 66
MINUS                : 38 51
MODULO               : 41
MULTIPLY             : 39
MULTI_COMMENT        : 
NEQ                  : 43
NOT                  : 52
NUMBER               : 2
NUM_LIT              : 29
OR                   : 48
PLUS                 : 37 50
RETURN               : 19
R_BKT                : 35 36
R_BRC                : 23 61 62 63 64 65 66
R_PAR                : 8 20 21 22 28 59 60 61 62 63 64 65 66
SEMI                 : 13 14 15 16 17 18 19 24 25
SINGLE_COMMENT       : 
STRING               : 4
STR_LIT              : 31
VOID                 : 6
WHILE                : 22
error                : 

Nonterminals, with rules where they appear

arg_list             : 35 54 60
binary_operation     : 26
block                : 1 12 23 61 62 63 64 65 66
expression           : 13 14 17 18 19 20 21 22 28 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 51 52 53 54 59 60
function_call        : 32
lambda               : 33
param_list           : 55 56 65 66
program              : 0
statement            : 11 12 20 20 21 22
type                 : 7 7 9 10 16 18 56 58 62 64 66
typelist             : 8 9
unary_operation      : 27

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (11) block -> . statement
    (12) block -> . statement block
    (13) statement -> . expression SEMI
    (14) statement -> . IDEN ASSIGN expression SEMI
    (15) statement -> . LET IDEN SEMI
    (16) statement -> . LET IDEN COLON type SEMI
    (17) statement -> . LET IDEN ASSIGN expression SEMI
    (18) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (19) statement -> . RETURN expression SEMI
    (20) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (21) statement -> . IF L_PAR expression R_PAR statement
    (22) statement -> . WHILE L_PAR expression R_PAR statement
    (23) statement -> . L_BRC block R_BRC
    (24) statement -> . BREAK SEMI
    (25) statement -> . CONTINUE SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    program                        shift and go to state 1
    block                          shift and go to state 2
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (11) block -> statement .
    (12) block -> statement . block
    (11) block -> . statement
    (12) block -> . statement block
    (13) statement -> . expression SEMI
    (14) statement -> . IDEN ASSIGN expression SEMI
    (15) statement -> . LET IDEN SEMI
    (16) statement -> . LET IDEN COLON type SEMI
    (17) statement -> . LET IDEN ASSIGN expression SEMI
    (18) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (19) statement -> . RETURN expression SEMI
    (20) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (21) statement -> . IF L_PAR expression R_PAR statement
    (22) statement -> . WHILE L_PAR expression R_PAR statement
    (23) statement -> . L_BRC block R_BRC
    (24) statement -> . BREAK SEMI
    (25) statement -> . CONTINUE SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    $end            reduce using rule 11 (block -> statement .)
    R_BRC           reduce using rule 11 (block -> statement .)
    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    statement                      shift and go to state 3
    block                          shift and go to state 25
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 4

    (13) statement -> expression . SEMI
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 26
    L_BKT           shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    EQ              shift and go to state 33
    NEQ             shift and go to state 34
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38
    OR              shift and go to state 39
    AND             shift and go to state 40
    L_PAR           shift and go to state 41


state 5

    (14) statement -> IDEN . ASSIGN expression SEMI
    (34) expression -> IDEN .

    ASSIGN          shift and go to state 42
    SEMI            reduce using rule 34 (expression -> IDEN .)
    L_BKT           reduce using rule 34 (expression -> IDEN .)
    PLUS            reduce using rule 34 (expression -> IDEN .)
    MINUS           reduce using rule 34 (expression -> IDEN .)
    MULTIPLY        reduce using rule 34 (expression -> IDEN .)
    DIVIDE          reduce using rule 34 (expression -> IDEN .)
    MODULO          reduce using rule 34 (expression -> IDEN .)
    EQ              reduce using rule 34 (expression -> IDEN .)
    NEQ             reduce using rule 34 (expression -> IDEN .)
    LT              reduce using rule 34 (expression -> IDEN .)
    GT              reduce using rule 34 (expression -> IDEN .)
    LEQ             reduce using rule 34 (expression -> IDEN .)
    GEQ             reduce using rule 34 (expression -> IDEN .)
    OR              reduce using rule 34 (expression -> IDEN .)
    AND             reduce using rule 34 (expression -> IDEN .)
    L_PAR           reduce using rule 34 (expression -> IDEN .)


state 6

    (15) statement -> LET . IDEN SEMI
    (16) statement -> LET . IDEN COLON type SEMI
    (17) statement -> LET . IDEN ASSIGN expression SEMI
    (18) statement -> LET . IDEN COLON type ASSIGN expression SEMI

    IDEN            shift and go to state 43


state 7

    (19) statement -> RETURN . expression SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 44
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 8

    (20) statement -> IF . L_PAR expression R_PAR statement ELSE statement
    (21) statement -> IF . L_PAR expression R_PAR statement

    L_PAR           shift and go to state 46


state 9

    (28) expression -> L_PAR . expression R_PAR
    (61) lambda -> L_PAR . R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> L_PAR . R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> L_PAR . IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> L_PAR . IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> L_PAR . param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> L_PAR . param_list R_PAR COLON type ARROW L_BRC block R_BRC
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (55) param_list -> . IDEN COMMA param_list
    (56) param_list -> . IDEN COLON type COMMA param_list
    (57) param_list -> . IDEN
    (58) param_list -> . IDEN COLON type
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    R_PAR           shift and go to state 48
    IDEN            shift and go to state 49
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 47
    param_list                     shift and go to state 50
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 10

    (22) statement -> WHILE . L_PAR expression R_PAR statement

    L_PAR           shift and go to state 51


state 11

    (23) statement -> L_BRC . block R_BRC
    (11) block -> . statement
    (12) block -> . statement block
    (13) statement -> . expression SEMI
    (14) statement -> . IDEN ASSIGN expression SEMI
    (15) statement -> . LET IDEN SEMI
    (16) statement -> . LET IDEN COLON type SEMI
    (17) statement -> . LET IDEN ASSIGN expression SEMI
    (18) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (19) statement -> . RETURN expression SEMI
    (20) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (21) statement -> . IF L_PAR expression R_PAR statement
    (22) statement -> . WHILE L_PAR expression R_PAR statement
    (23) statement -> . L_BRC block R_BRC
    (24) statement -> . BREAK SEMI
    (25) statement -> . CONTINUE SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    block                          shift and go to state 52
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 12

    (24) statement -> BREAK . SEMI

    SEMI            shift and go to state 53


state 13

    (25) statement -> CONTINUE . SEMI

    SEMI            shift and go to state 54


state 14

    (26) expression -> binary_operation .

    SEMI            reduce using rule 26 (expression -> binary_operation .)
    L_BKT           reduce using rule 26 (expression -> binary_operation .)
    PLUS            reduce using rule 26 (expression -> binary_operation .)
    MINUS           reduce using rule 26 (expression -> binary_operation .)
    MULTIPLY        reduce using rule 26 (expression -> binary_operation .)
    DIVIDE          reduce using rule 26 (expression -> binary_operation .)
    MODULO          reduce using rule 26 (expression -> binary_operation .)
    EQ              reduce using rule 26 (expression -> binary_operation .)
    NEQ             reduce using rule 26 (expression -> binary_operation .)
    LT              reduce using rule 26 (expression -> binary_operation .)
    GT              reduce using rule 26 (expression -> binary_operation .)
    LEQ             reduce using rule 26 (expression -> binary_operation .)
    GEQ             reduce using rule 26 (expression -> binary_operation .)
    OR              reduce using rule 26 (expression -> binary_operation .)
    AND             reduce using rule 26 (expression -> binary_operation .)
    L_PAR           reduce using rule 26 (expression -> binary_operation .)
    R_PAR           reduce using rule 26 (expression -> binary_operation .)
    COMMA           reduce using rule 26 (expression -> binary_operation .)
    R_BKT           reduce using rule 26 (expression -> binary_operation .)


state 15

    (27) expression -> unary_operation .

    SEMI            reduce using rule 27 (expression -> unary_operation .)
    L_BKT           reduce using rule 27 (expression -> unary_operation .)
    PLUS            reduce using rule 27 (expression -> unary_operation .)
    MINUS           reduce using rule 27 (expression -> unary_operation .)
    MULTIPLY        reduce using rule 27 (expression -> unary_operation .)
    DIVIDE          reduce using rule 27 (expression -> unary_operation .)
    MODULO          reduce using rule 27 (expression -> unary_operation .)
    EQ              reduce using rule 27 (expression -> unary_operation .)
    NEQ             reduce using rule 27 (expression -> unary_operation .)
    LT              reduce using rule 27 (expression -> unary_operation .)
    GT              reduce using rule 27 (expression -> unary_operation .)
    LEQ             reduce using rule 27 (expression -> unary_operation .)
    GEQ             reduce using rule 27 (expression -> unary_operation .)
    OR              reduce using rule 27 (expression -> unary_operation .)
    AND             reduce using rule 27 (expression -> unary_operation .)
    L_PAR           reduce using rule 27 (expression -> unary_operation .)
    R_PAR           reduce using rule 27 (expression -> unary_operation .)
    COMMA           reduce using rule 27 (expression -> unary_operation .)
    R_BKT           reduce using rule 27 (expression -> unary_operation .)


state 16

    (29) expression -> NUM_LIT .

    SEMI            reduce using rule 29 (expression -> NUM_LIT .)
    L_BKT           reduce using rule 29 (expression -> NUM_LIT .)
    PLUS            reduce using rule 29 (expression -> NUM_LIT .)
    MINUS           reduce using rule 29 (expression -> NUM_LIT .)
    MULTIPLY        reduce using rule 29 (expression -> NUM_LIT .)
    DIVIDE          reduce using rule 29 (expression -> NUM_LIT .)
    MODULO          reduce using rule 29 (expression -> NUM_LIT .)
    EQ              reduce using rule 29 (expression -> NUM_LIT .)
    NEQ             reduce using rule 29 (expression -> NUM_LIT .)
    LT              reduce using rule 29 (expression -> NUM_LIT .)
    GT              reduce using rule 29 (expression -> NUM_LIT .)
    LEQ             reduce using rule 29 (expression -> NUM_LIT .)
    GEQ             reduce using rule 29 (expression -> NUM_LIT .)
    OR              reduce using rule 29 (expression -> NUM_LIT .)
    AND             reduce using rule 29 (expression -> NUM_LIT .)
    L_PAR           reduce using rule 29 (expression -> NUM_LIT .)
    R_PAR           reduce using rule 29 (expression -> NUM_LIT .)
    COMMA           reduce using rule 29 (expression -> NUM_LIT .)
    R_BKT           reduce using rule 29 (expression -> NUM_LIT .)


state 17

    (30) expression -> BOOL_LIT .

    SEMI            reduce using rule 30 (expression -> BOOL_LIT .)
    L_BKT           reduce using rule 30 (expression -> BOOL_LIT .)
    PLUS            reduce using rule 30 (expression -> BOOL_LIT .)
    MINUS           reduce using rule 30 (expression -> BOOL_LIT .)
    MULTIPLY        reduce using rule 30 (expression -> BOOL_LIT .)
    DIVIDE          reduce using rule 30 (expression -> BOOL_LIT .)
    MODULO          reduce using rule 30 (expression -> BOOL_LIT .)
    EQ              reduce using rule 30 (expression -> BOOL_LIT .)
    NEQ             reduce using rule 30 (expression -> BOOL_LIT .)
    LT              reduce using rule 30 (expression -> BOOL_LIT .)
    GT              reduce using rule 30 (expression -> BOOL_LIT .)
    LEQ             reduce using rule 30 (expression -> BOOL_LIT .)
    GEQ             reduce using rule 30 (expression -> BOOL_LIT .)
    OR              reduce using rule 30 (expression -> BOOL_LIT .)
    AND             reduce using rule 30 (expression -> BOOL_LIT .)
    L_PAR           reduce using rule 30 (expression -> BOOL_LIT .)
    R_PAR           reduce using rule 30 (expression -> BOOL_LIT .)
    COMMA           reduce using rule 30 (expression -> BOOL_LIT .)
    R_BKT           reduce using rule 30 (expression -> BOOL_LIT .)


state 18

    (31) expression -> STR_LIT .

    SEMI            reduce using rule 31 (expression -> STR_LIT .)
    L_BKT           reduce using rule 31 (expression -> STR_LIT .)
    PLUS            reduce using rule 31 (expression -> STR_LIT .)
    MINUS           reduce using rule 31 (expression -> STR_LIT .)
    MULTIPLY        reduce using rule 31 (expression -> STR_LIT .)
    DIVIDE          reduce using rule 31 (expression -> STR_LIT .)
    MODULO          reduce using rule 31 (expression -> STR_LIT .)
    EQ              reduce using rule 31 (expression -> STR_LIT .)
    NEQ             reduce using rule 31 (expression -> STR_LIT .)
    LT              reduce using rule 31 (expression -> STR_LIT .)
    GT              reduce using rule 31 (expression -> STR_LIT .)
    LEQ             reduce using rule 31 (expression -> STR_LIT .)
    GEQ             reduce using rule 31 (expression -> STR_LIT .)
    OR              reduce using rule 31 (expression -> STR_LIT .)
    AND             reduce using rule 31 (expression -> STR_LIT .)
    L_PAR           reduce using rule 31 (expression -> STR_LIT .)
    R_PAR           reduce using rule 31 (expression -> STR_LIT .)
    COMMA           reduce using rule 31 (expression -> STR_LIT .)
    R_BKT           reduce using rule 31 (expression -> STR_LIT .)


state 19

    (32) expression -> function_call .

    SEMI            reduce using rule 32 (expression -> function_call .)
    L_BKT           reduce using rule 32 (expression -> function_call .)
    PLUS            reduce using rule 32 (expression -> function_call .)
    MINUS           reduce using rule 32 (expression -> function_call .)
    MULTIPLY        reduce using rule 32 (expression -> function_call .)
    DIVIDE          reduce using rule 32 (expression -> function_call .)
    MODULO          reduce using rule 32 (expression -> function_call .)
    EQ              reduce using rule 32 (expression -> function_call .)
    NEQ             reduce using rule 32 (expression -> function_call .)
    LT              reduce using rule 32 (expression -> function_call .)
    GT              reduce using rule 32 (expression -> function_call .)
    LEQ             reduce using rule 32 (expression -> function_call .)
    GEQ             reduce using rule 32 (expression -> function_call .)
    OR              reduce using rule 32 (expression -> function_call .)
    AND             reduce using rule 32 (expression -> function_call .)
    L_PAR           reduce using rule 32 (expression -> function_call .)
    R_PAR           reduce using rule 32 (expression -> function_call .)
    COMMA           reduce using rule 32 (expression -> function_call .)
    R_BKT           reduce using rule 32 (expression -> function_call .)


state 20

    (33) expression -> lambda .

    SEMI            reduce using rule 33 (expression -> lambda .)
    L_BKT           reduce using rule 33 (expression -> lambda .)
    PLUS            reduce using rule 33 (expression -> lambda .)
    MINUS           reduce using rule 33 (expression -> lambda .)
    MULTIPLY        reduce using rule 33 (expression -> lambda .)
    DIVIDE          reduce using rule 33 (expression -> lambda .)
    MODULO          reduce using rule 33 (expression -> lambda .)
    EQ              reduce using rule 33 (expression -> lambda .)
    NEQ             reduce using rule 33 (expression -> lambda .)
    LT              reduce using rule 33 (expression -> lambda .)
    GT              reduce using rule 33 (expression -> lambda .)
    LEQ             reduce using rule 33 (expression -> lambda .)
    GEQ             reduce using rule 33 (expression -> lambda .)
    OR              reduce using rule 33 (expression -> lambda .)
    AND             reduce using rule 33 (expression -> lambda .)
    L_PAR           reduce using rule 33 (expression -> lambda .)
    R_PAR           reduce using rule 33 (expression -> lambda .)
    COMMA           reduce using rule 33 (expression -> lambda .)
    R_BKT           reduce using rule 33 (expression -> lambda .)


state 21

    (35) expression -> L_BKT . arg_list R_BKT
    (53) arg_list -> . expression
    (54) arg_list -> . expression COMMA arg_list
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    arg_list                       shift and go to state 55
    expression                     shift and go to state 56
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 22

    (50) unary_operation -> PLUS . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 57
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 23

    (51) unary_operation -> MINUS . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 58
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 24

    (52) unary_operation -> NOT . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 59
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 25

    (12) block -> statement block .

    $end            reduce using rule 12 (block -> statement block .)
    R_BRC           reduce using rule 12 (block -> statement block .)


state 26

    (13) statement -> expression SEMI .

    IDEN            reduce using rule 13 (statement -> expression SEMI .)
    LET             reduce using rule 13 (statement -> expression SEMI .)
    RETURN          reduce using rule 13 (statement -> expression SEMI .)
    IF              reduce using rule 13 (statement -> expression SEMI .)
    WHILE           reduce using rule 13 (statement -> expression SEMI .)
    L_BRC           reduce using rule 13 (statement -> expression SEMI .)
    BREAK           reduce using rule 13 (statement -> expression SEMI .)
    CONTINUE        reduce using rule 13 (statement -> expression SEMI .)
    L_PAR           reduce using rule 13 (statement -> expression SEMI .)
    NUM_LIT         reduce using rule 13 (statement -> expression SEMI .)
    BOOL_LIT        reduce using rule 13 (statement -> expression SEMI .)
    STR_LIT         reduce using rule 13 (statement -> expression SEMI .)
    L_BKT           reduce using rule 13 (statement -> expression SEMI .)
    PLUS            reduce using rule 13 (statement -> expression SEMI .)
    MINUS           reduce using rule 13 (statement -> expression SEMI .)
    NOT             reduce using rule 13 (statement -> expression SEMI .)
    $end            reduce using rule 13 (statement -> expression SEMI .)
    R_BRC           reduce using rule 13 (statement -> expression SEMI .)
    ELSE            reduce using rule 13 (statement -> expression SEMI .)


state 27

    (36) expression -> expression L_BKT . expression R_BKT
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 60
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 28

    (37) binary_operation -> expression PLUS . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 61
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 29

    (38) binary_operation -> expression MINUS . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 62
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 30

    (39) binary_operation -> expression MULTIPLY . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 63
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 31

    (40) binary_operation -> expression DIVIDE . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 64
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 32

    (41) binary_operation -> expression MODULO . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 65
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 33

    (42) binary_operation -> expression EQ . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 66
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 34

    (43) binary_operation -> expression NEQ . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 67
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 35

    (44) binary_operation -> expression LT . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 68
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 36

    (45) binary_operation -> expression GT . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 69
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 37

    (46) binary_operation -> expression LEQ . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 70
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 38

    (47) binary_operation -> expression GEQ . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 71
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 39

    (48) binary_operation -> expression OR . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 72
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 40

    (49) binary_operation -> expression AND . expression
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 73
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 41

    (59) function_call -> expression L_PAR . R_PAR
    (60) function_call -> expression L_PAR . arg_list R_PAR
    (53) arg_list -> . expression
    (54) arg_list -> . expression COMMA arg_list
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    R_PAR           shift and go to state 74
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 56
    arg_list                       shift and go to state 75
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 42

    (14) statement -> IDEN ASSIGN . expression SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 76
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 43

    (15) statement -> LET IDEN . SEMI
    (16) statement -> LET IDEN . COLON type SEMI
    (17) statement -> LET IDEN . ASSIGN expression SEMI
    (18) statement -> LET IDEN . COLON type ASSIGN expression SEMI

    SEMI            shift and go to state 77
    COLON           shift and go to state 78
    ASSIGN          shift and go to state 79


state 44

    (19) statement -> RETURN expression . SEMI
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 80
    L_BKT           shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    EQ              shift and go to state 33
    NEQ             shift and go to state 34
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38
    OR              shift and go to state 39
    AND             shift and go to state 40
    L_PAR           shift and go to state 41


state 45

    (34) expression -> IDEN .

    SEMI            reduce using rule 34 (expression -> IDEN .)
    L_BKT           reduce using rule 34 (expression -> IDEN .)
    PLUS            reduce using rule 34 (expression -> IDEN .)
    MINUS           reduce using rule 34 (expression -> IDEN .)
    MULTIPLY        reduce using rule 34 (expression -> IDEN .)
    DIVIDE          reduce using rule 34 (expression -> IDEN .)
    MODULO          reduce using rule 34 (expression -> IDEN .)
    EQ              reduce using rule 34 (expression -> IDEN .)
    NEQ             reduce using rule 34 (expression -> IDEN .)
    LT              reduce using rule 34 (expression -> IDEN .)
    GT              reduce using rule 34 (expression -> IDEN .)
    LEQ             reduce using rule 34 (expression -> IDEN .)
    GEQ             reduce using rule 34 (expression -> IDEN .)
    OR              reduce using rule 34 (expression -> IDEN .)
    AND             reduce using rule 34 (expression -> IDEN .)
    L_PAR           reduce using rule 34 (expression -> IDEN .)
    COMMA           reduce using rule 34 (expression -> IDEN .)
    R_BKT           reduce using rule 34 (expression -> IDEN .)
    R_PAR           reduce using rule 34 (expression -> IDEN .)


state 46

    (20) statement -> IF L_PAR . expression R_PAR statement ELSE statement
    (21) statement -> IF L_PAR . expression R_PAR statement
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 81
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 47

    (28) expression -> L_PAR expression . R_PAR
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    R_PAR           shift and go to state 82
    L_BKT           shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    EQ              shift and go to state 33
    NEQ             shift and go to state 34
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38
    OR              shift and go to state 39
    AND             shift and go to state 40
    L_PAR           shift and go to state 41


state 48

    (61) lambda -> L_PAR R_PAR . ARROW L_BRC block R_BRC
    (62) lambda -> L_PAR R_PAR . COLON type ARROW L_BRC block R_BRC

    ARROW           shift and go to state 83
    COLON           shift and go to state 84


state 49

    (63) lambda -> L_PAR IDEN . R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> L_PAR IDEN . R_PAR COLON type ARROW L_BRC block R_BRC
    (34) expression -> IDEN .
    (55) param_list -> IDEN . COMMA param_list
    (56) param_list -> IDEN . COLON type COMMA param_list
    (57) param_list -> IDEN .
    (58) param_list -> IDEN . COLON type

  ! shift/reduce conflict for R_PAR resolved as shift
  ! shift/reduce conflict for R_PAR resolved as shift
    R_PAR           shift and go to state 85
    L_BKT           reduce using rule 34 (expression -> IDEN .)
    PLUS            reduce using rule 34 (expression -> IDEN .)
    MINUS           reduce using rule 34 (expression -> IDEN .)
    MULTIPLY        reduce using rule 34 (expression -> IDEN .)
    DIVIDE          reduce using rule 34 (expression -> IDEN .)
    MODULO          reduce using rule 34 (expression -> IDEN .)
    EQ              reduce using rule 34 (expression -> IDEN .)
    NEQ             reduce using rule 34 (expression -> IDEN .)
    LT              reduce using rule 34 (expression -> IDEN .)
    GT              reduce using rule 34 (expression -> IDEN .)
    LEQ             reduce using rule 34 (expression -> IDEN .)
    GEQ             reduce using rule 34 (expression -> IDEN .)
    OR              reduce using rule 34 (expression -> IDEN .)
    AND             reduce using rule 34 (expression -> IDEN .)
    L_PAR           reduce using rule 34 (expression -> IDEN .)
    COMMA           shift and go to state 87
    COLON           shift and go to state 86

  ! R_PAR           [ reduce using rule 34 (expression -> IDEN .) ]
  ! R_PAR           [ reduce using rule 57 (param_list -> IDEN .) ]


state 50

    (65) lambda -> L_PAR param_list . R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> L_PAR param_list . R_PAR COLON type ARROW L_BRC block R_BRC

    R_PAR           shift and go to state 88


state 51

    (22) statement -> WHILE L_PAR . expression R_PAR statement
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 89
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 52

    (23) statement -> L_BRC block . R_BRC

    R_BRC           shift and go to state 90


state 53

    (24) statement -> BREAK SEMI .

    IDEN            reduce using rule 24 (statement -> BREAK SEMI .)
    LET             reduce using rule 24 (statement -> BREAK SEMI .)
    RETURN          reduce using rule 24 (statement -> BREAK SEMI .)
    IF              reduce using rule 24 (statement -> BREAK SEMI .)
    WHILE           reduce using rule 24 (statement -> BREAK SEMI .)
    L_BRC           reduce using rule 24 (statement -> BREAK SEMI .)
    BREAK           reduce using rule 24 (statement -> BREAK SEMI .)
    CONTINUE        reduce using rule 24 (statement -> BREAK SEMI .)
    L_PAR           reduce using rule 24 (statement -> BREAK SEMI .)
    NUM_LIT         reduce using rule 24 (statement -> BREAK SEMI .)
    BOOL_LIT        reduce using rule 24 (statement -> BREAK SEMI .)
    STR_LIT         reduce using rule 24 (statement -> BREAK SEMI .)
    L_BKT           reduce using rule 24 (statement -> BREAK SEMI .)
    PLUS            reduce using rule 24 (statement -> BREAK SEMI .)
    MINUS           reduce using rule 24 (statement -> BREAK SEMI .)
    NOT             reduce using rule 24 (statement -> BREAK SEMI .)
    $end            reduce using rule 24 (statement -> BREAK SEMI .)
    R_BRC           reduce using rule 24 (statement -> BREAK SEMI .)
    ELSE            reduce using rule 24 (statement -> BREAK SEMI .)


state 54

    (25) statement -> CONTINUE SEMI .

    IDEN            reduce using rule 25 (statement -> CONTINUE SEMI .)
    LET             reduce using rule 25 (statement -> CONTINUE SEMI .)
    RETURN          reduce using rule 25 (statement -> CONTINUE SEMI .)
    IF              reduce using rule 25 (statement -> CONTINUE SEMI .)
    WHILE           reduce using rule 25 (statement -> CONTINUE SEMI .)
    L_BRC           reduce using rule 25 (statement -> CONTINUE SEMI .)
    BREAK           reduce using rule 25 (statement -> CONTINUE SEMI .)
    CONTINUE        reduce using rule 25 (statement -> CONTINUE SEMI .)
    L_PAR           reduce using rule 25 (statement -> CONTINUE SEMI .)
    NUM_LIT         reduce using rule 25 (statement -> CONTINUE SEMI .)
    BOOL_LIT        reduce using rule 25 (statement -> CONTINUE SEMI .)
    STR_LIT         reduce using rule 25 (statement -> CONTINUE SEMI .)
    L_BKT           reduce using rule 25 (statement -> CONTINUE SEMI .)
    PLUS            reduce using rule 25 (statement -> CONTINUE SEMI .)
    MINUS           reduce using rule 25 (statement -> CONTINUE SEMI .)
    NOT             reduce using rule 25 (statement -> CONTINUE SEMI .)
    $end            reduce using rule 25 (statement -> CONTINUE SEMI .)
    R_BRC           reduce using rule 25 (statement -> CONTINUE SEMI .)
    ELSE            reduce using rule 25 (statement -> CONTINUE SEMI .)


state 55

    (35) expression -> L_BKT arg_list . R_BKT

    R_BKT           shift and go to state 91


state 56

    (53) arg_list -> expression .
    (54) arg_list -> expression . COMMA arg_list
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    R_BKT           reduce using rule 53 (arg_list -> expression .)
    R_PAR           reduce using rule 53 (arg_list -> expression .)
    COMMA           shift and go to state 92
    L_BKT           shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    EQ              shift and go to state 33
    NEQ             shift and go to state 34
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38
    OR              shift and go to state 39
    AND             shift and go to state 40
    L_PAR           shift and go to state 41


state 57

    (50) unary_operation -> PLUS expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 50 (unary_operation -> PLUS expression .)
    L_BKT           reduce using rule 50 (unary_operation -> PLUS expression .)
    PLUS            reduce using rule 50 (unary_operation -> PLUS expression .)
    MINUS           reduce using rule 50 (unary_operation -> PLUS expression .)
    MULTIPLY        reduce using rule 50 (unary_operation -> PLUS expression .)
    DIVIDE          reduce using rule 50 (unary_operation -> PLUS expression .)
    MODULO          reduce using rule 50 (unary_operation -> PLUS expression .)
    EQ              reduce using rule 50 (unary_operation -> PLUS expression .)
    NEQ             reduce using rule 50 (unary_operation -> PLUS expression .)
    LT              reduce using rule 50 (unary_operation -> PLUS expression .)
    GT              reduce using rule 50 (unary_operation -> PLUS expression .)
    LEQ             reduce using rule 50 (unary_operation -> PLUS expression .)
    GEQ             reduce using rule 50 (unary_operation -> PLUS expression .)
    OR              reduce using rule 50 (unary_operation -> PLUS expression .)
    AND             reduce using rule 50 (unary_operation -> PLUS expression .)
    L_PAR           reduce using rule 50 (unary_operation -> PLUS expression .)
    R_PAR           reduce using rule 50 (unary_operation -> PLUS expression .)
    COMMA           reduce using rule 50 (unary_operation -> PLUS expression .)
    R_BKT           reduce using rule 50 (unary_operation -> PLUS expression .)

  ! L_BKT           [ shift and go to state 27 ]
  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! MULTIPLY        [ shift and go to state 30 ]
  ! DIVIDE          [ shift and go to state 31 ]
  ! MODULO          [ shift and go to state 32 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! LT              [ shift and go to state 35 ]
  ! GT              [ shift and go to state 36 ]
  ! LEQ             [ shift and go to state 37 ]
  ! GEQ             [ shift and go to state 38 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 58

    (51) unary_operation -> MINUS expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 51 (unary_operation -> MINUS expression .)
    L_BKT           reduce using rule 51 (unary_operation -> MINUS expression .)
    PLUS            reduce using rule 51 (unary_operation -> MINUS expression .)
    MINUS           reduce using rule 51 (unary_operation -> MINUS expression .)
    MULTIPLY        reduce using rule 51 (unary_operation -> MINUS expression .)
    DIVIDE          reduce using rule 51 (unary_operation -> MINUS expression .)
    MODULO          reduce using rule 51 (unary_operation -> MINUS expression .)
    EQ              reduce using rule 51 (unary_operation -> MINUS expression .)
    NEQ             reduce using rule 51 (unary_operation -> MINUS expression .)
    LT              reduce using rule 51 (unary_operation -> MINUS expression .)
    GT              reduce using rule 51 (unary_operation -> MINUS expression .)
    LEQ             reduce using rule 51 (unary_operation -> MINUS expression .)
    GEQ             reduce using rule 51 (unary_operation -> MINUS expression .)
    OR              reduce using rule 51 (unary_operation -> MINUS expression .)
    AND             reduce using rule 51 (unary_operation -> MINUS expression .)
    L_PAR           reduce using rule 51 (unary_operation -> MINUS expression .)
    R_PAR           reduce using rule 51 (unary_operation -> MINUS expression .)
    COMMA           reduce using rule 51 (unary_operation -> MINUS expression .)
    R_BKT           reduce using rule 51 (unary_operation -> MINUS expression .)

  ! L_BKT           [ shift and go to state 27 ]
  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! MULTIPLY        [ shift and go to state 30 ]
  ! DIVIDE          [ shift and go to state 31 ]
  ! MODULO          [ shift and go to state 32 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! LT              [ shift and go to state 35 ]
  ! GT              [ shift and go to state 36 ]
  ! LEQ             [ shift and go to state 37 ]
  ! GEQ             [ shift and go to state 38 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 59

    (52) unary_operation -> NOT expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 52 (unary_operation -> NOT expression .)
    L_BKT           reduce using rule 52 (unary_operation -> NOT expression .)
    PLUS            reduce using rule 52 (unary_operation -> NOT expression .)
    MINUS           reduce using rule 52 (unary_operation -> NOT expression .)
    MULTIPLY        reduce using rule 52 (unary_operation -> NOT expression .)
    DIVIDE          reduce using rule 52 (unary_operation -> NOT expression .)
    MODULO          reduce using rule 52 (unary_operation -> NOT expression .)
    EQ              reduce using rule 52 (unary_operation -> NOT expression .)
    NEQ             reduce using rule 52 (unary_operation -> NOT expression .)
    LT              reduce using rule 52 (unary_operation -> NOT expression .)
    GT              reduce using rule 52 (unary_operation -> NOT expression .)
    LEQ             reduce using rule 52 (unary_operation -> NOT expression .)
    GEQ             reduce using rule 52 (unary_operation -> NOT expression .)
    OR              reduce using rule 52 (unary_operation -> NOT expression .)
    AND             reduce using rule 52 (unary_operation -> NOT expression .)
    L_PAR           reduce using rule 52 (unary_operation -> NOT expression .)
    R_PAR           reduce using rule 52 (unary_operation -> NOT expression .)
    COMMA           reduce using rule 52 (unary_operation -> NOT expression .)
    R_BKT           reduce using rule 52 (unary_operation -> NOT expression .)

  ! L_BKT           [ shift and go to state 27 ]
  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! MULTIPLY        [ shift and go to state 30 ]
  ! DIVIDE          [ shift and go to state 31 ]
  ! MODULO          [ shift and go to state 32 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! LT              [ shift and go to state 35 ]
  ! GT              [ shift and go to state 36 ]
  ! LEQ             [ shift and go to state 37 ]
  ! GEQ             [ shift and go to state 38 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 60

    (36) expression -> expression L_BKT expression . R_BKT
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    R_BKT           shift and go to state 93
    L_BKT           shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    EQ              shift and go to state 33
    NEQ             shift and go to state 34
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38
    OR              shift and go to state 39
    AND             shift and go to state 40
    L_PAR           shift and go to state 41


state 61

    (37) binary_operation -> expression PLUS expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 37 (binary_operation -> expression PLUS expression .)
    L_BKT           reduce using rule 37 (binary_operation -> expression PLUS expression .)
    PLUS            reduce using rule 37 (binary_operation -> expression PLUS expression .)
    MINUS           reduce using rule 37 (binary_operation -> expression PLUS expression .)
    EQ              reduce using rule 37 (binary_operation -> expression PLUS expression .)
    NEQ             reduce using rule 37 (binary_operation -> expression PLUS expression .)
    LT              reduce using rule 37 (binary_operation -> expression PLUS expression .)
    GT              reduce using rule 37 (binary_operation -> expression PLUS expression .)
    LEQ             reduce using rule 37 (binary_operation -> expression PLUS expression .)
    GEQ             reduce using rule 37 (binary_operation -> expression PLUS expression .)
    OR              reduce using rule 37 (binary_operation -> expression PLUS expression .)
    AND             reduce using rule 37 (binary_operation -> expression PLUS expression .)
    L_PAR           reduce using rule 37 (binary_operation -> expression PLUS expression .)
    R_PAR           reduce using rule 37 (binary_operation -> expression PLUS expression .)
    COMMA           reduce using rule 37 (binary_operation -> expression PLUS expression .)
    R_BKT           reduce using rule 37 (binary_operation -> expression PLUS expression .)
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32

  ! MULTIPLY        [ reduce using rule 37 (binary_operation -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 37 (binary_operation -> expression PLUS expression .) ]
  ! MODULO          [ reduce using rule 37 (binary_operation -> expression PLUS expression .) ]
  ! L_BKT           [ shift and go to state 27 ]
  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! LT              [ shift and go to state 35 ]
  ! GT              [ shift and go to state 36 ]
  ! LEQ             [ shift and go to state 37 ]
  ! GEQ             [ shift and go to state 38 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 62

    (38) binary_operation -> expression MINUS expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 38 (binary_operation -> expression MINUS expression .)
    L_BKT           reduce using rule 38 (binary_operation -> expression MINUS expression .)
    PLUS            reduce using rule 38 (binary_operation -> expression MINUS expression .)
    MINUS           reduce using rule 38 (binary_operation -> expression MINUS expression .)
    EQ              reduce using rule 38 (binary_operation -> expression MINUS expression .)
    NEQ             reduce using rule 38 (binary_operation -> expression MINUS expression .)
    LT              reduce using rule 38 (binary_operation -> expression MINUS expression .)
    GT              reduce using rule 38 (binary_operation -> expression MINUS expression .)
    LEQ             reduce using rule 38 (binary_operation -> expression MINUS expression .)
    GEQ             reduce using rule 38 (binary_operation -> expression MINUS expression .)
    OR              reduce using rule 38 (binary_operation -> expression MINUS expression .)
    AND             reduce using rule 38 (binary_operation -> expression MINUS expression .)
    L_PAR           reduce using rule 38 (binary_operation -> expression MINUS expression .)
    R_PAR           reduce using rule 38 (binary_operation -> expression MINUS expression .)
    COMMA           reduce using rule 38 (binary_operation -> expression MINUS expression .)
    R_BKT           reduce using rule 38 (binary_operation -> expression MINUS expression .)
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32

  ! MULTIPLY        [ reduce using rule 38 (binary_operation -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 38 (binary_operation -> expression MINUS expression .) ]
  ! MODULO          [ reduce using rule 38 (binary_operation -> expression MINUS expression .) ]
  ! L_BKT           [ shift and go to state 27 ]
  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! LT              [ shift and go to state 35 ]
  ! GT              [ shift and go to state 36 ]
  ! LEQ             [ shift and go to state 37 ]
  ! GEQ             [ shift and go to state 38 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 63

    (39) binary_operation -> expression MULTIPLY expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    L_BKT           reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    PLUS            reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    MINUS           reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    MULTIPLY        reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    DIVIDE          reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    MODULO          reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    EQ              reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    NEQ             reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    LT              reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    GT              reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    LEQ             reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    GEQ             reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    OR              reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    AND             reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    L_PAR           reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    R_PAR           reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    COMMA           reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)
    R_BKT           reduce using rule 39 (binary_operation -> expression MULTIPLY expression .)

  ! L_BKT           [ shift and go to state 27 ]
  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! MULTIPLY        [ shift and go to state 30 ]
  ! DIVIDE          [ shift and go to state 31 ]
  ! MODULO          [ shift and go to state 32 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! LT              [ shift and go to state 35 ]
  ! GT              [ shift and go to state 36 ]
  ! LEQ             [ shift and go to state 37 ]
  ! GEQ             [ shift and go to state 38 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 64

    (40) binary_operation -> expression DIVIDE expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    L_BKT           reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    PLUS            reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    MINUS           reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    MULTIPLY        reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    MODULO          reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    EQ              reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    NEQ             reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    LT              reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    GT              reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    LEQ             reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    GEQ             reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    OR              reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    AND             reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    L_PAR           reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    R_PAR           reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    COMMA           reduce using rule 40 (binary_operation -> expression DIVIDE expression .)
    R_BKT           reduce using rule 40 (binary_operation -> expression DIVIDE expression .)

  ! L_BKT           [ shift and go to state 27 ]
  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! MULTIPLY        [ shift and go to state 30 ]
  ! DIVIDE          [ shift and go to state 31 ]
  ! MODULO          [ shift and go to state 32 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! LT              [ shift and go to state 35 ]
  ! GT              [ shift and go to state 36 ]
  ! LEQ             [ shift and go to state 37 ]
  ! GEQ             [ shift and go to state 38 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 65

    (41) binary_operation -> expression MODULO expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 41 (binary_operation -> expression MODULO expression .)
    L_BKT           reduce using rule 41 (binary_operation -> expression MODULO expression .)
    PLUS            reduce using rule 41 (binary_operation -> expression MODULO expression .)
    MINUS           reduce using rule 41 (binary_operation -> expression MODULO expression .)
    MULTIPLY        reduce using rule 41 (binary_operation -> expression MODULO expression .)
    DIVIDE          reduce using rule 41 (binary_operation -> expression MODULO expression .)
    MODULO          reduce using rule 41 (binary_operation -> expression MODULO expression .)
    EQ              reduce using rule 41 (binary_operation -> expression MODULO expression .)
    NEQ             reduce using rule 41 (binary_operation -> expression MODULO expression .)
    LT              reduce using rule 41 (binary_operation -> expression MODULO expression .)
    GT              reduce using rule 41 (binary_operation -> expression MODULO expression .)
    LEQ             reduce using rule 41 (binary_operation -> expression MODULO expression .)
    GEQ             reduce using rule 41 (binary_operation -> expression MODULO expression .)
    OR              reduce using rule 41 (binary_operation -> expression MODULO expression .)
    AND             reduce using rule 41 (binary_operation -> expression MODULO expression .)
    L_PAR           reduce using rule 41 (binary_operation -> expression MODULO expression .)
    R_PAR           reduce using rule 41 (binary_operation -> expression MODULO expression .)
    COMMA           reduce using rule 41 (binary_operation -> expression MODULO expression .)
    R_BKT           reduce using rule 41 (binary_operation -> expression MODULO expression .)

  ! L_BKT           [ shift and go to state 27 ]
  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! MULTIPLY        [ shift and go to state 30 ]
  ! DIVIDE          [ shift and go to state 31 ]
  ! MODULO          [ shift and go to state 32 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! LT              [ shift and go to state 35 ]
  ! GT              [ shift and go to state 36 ]
  ! LEQ             [ shift and go to state 37 ]
  ! GEQ             [ shift and go to state 38 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 66

    (42) binary_operation -> expression EQ expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 42 (binary_operation -> expression EQ expression .)
    L_BKT           reduce using rule 42 (binary_operation -> expression EQ expression .)
    EQ              reduce using rule 42 (binary_operation -> expression EQ expression .)
    NEQ             reduce using rule 42 (binary_operation -> expression EQ expression .)
    OR              reduce using rule 42 (binary_operation -> expression EQ expression .)
    AND             reduce using rule 42 (binary_operation -> expression EQ expression .)
    L_PAR           reduce using rule 42 (binary_operation -> expression EQ expression .)
    R_PAR           reduce using rule 42 (binary_operation -> expression EQ expression .)
    COMMA           reduce using rule 42 (binary_operation -> expression EQ expression .)
    R_BKT           reduce using rule 42 (binary_operation -> expression EQ expression .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38

  ! PLUS            [ reduce using rule 42 (binary_operation -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 42 (binary_operation -> expression EQ expression .) ]
  ! MULTIPLY        [ reduce using rule 42 (binary_operation -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 42 (binary_operation -> expression EQ expression .) ]
  ! MODULO          [ reduce using rule 42 (binary_operation -> expression EQ expression .) ]
  ! LT              [ reduce using rule 42 (binary_operation -> expression EQ expression .) ]
  ! GT              [ reduce using rule 42 (binary_operation -> expression EQ expression .) ]
  ! LEQ             [ reduce using rule 42 (binary_operation -> expression EQ expression .) ]
  ! GEQ             [ reduce using rule 42 (binary_operation -> expression EQ expression .) ]
  ! L_BKT           [ shift and go to state 27 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 67

    (43) binary_operation -> expression NEQ expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 43 (binary_operation -> expression NEQ expression .)
    L_BKT           reduce using rule 43 (binary_operation -> expression NEQ expression .)
    EQ              reduce using rule 43 (binary_operation -> expression NEQ expression .)
    NEQ             reduce using rule 43 (binary_operation -> expression NEQ expression .)
    OR              reduce using rule 43 (binary_operation -> expression NEQ expression .)
    AND             reduce using rule 43 (binary_operation -> expression NEQ expression .)
    L_PAR           reduce using rule 43 (binary_operation -> expression NEQ expression .)
    R_PAR           reduce using rule 43 (binary_operation -> expression NEQ expression .)
    COMMA           reduce using rule 43 (binary_operation -> expression NEQ expression .)
    R_BKT           reduce using rule 43 (binary_operation -> expression NEQ expression .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38

  ! PLUS            [ reduce using rule 43 (binary_operation -> expression NEQ expression .) ]
  ! MINUS           [ reduce using rule 43 (binary_operation -> expression NEQ expression .) ]
  ! MULTIPLY        [ reduce using rule 43 (binary_operation -> expression NEQ expression .) ]
  ! DIVIDE          [ reduce using rule 43 (binary_operation -> expression NEQ expression .) ]
  ! MODULO          [ reduce using rule 43 (binary_operation -> expression NEQ expression .) ]
  ! LT              [ reduce using rule 43 (binary_operation -> expression NEQ expression .) ]
  ! GT              [ reduce using rule 43 (binary_operation -> expression NEQ expression .) ]
  ! LEQ             [ reduce using rule 43 (binary_operation -> expression NEQ expression .) ]
  ! GEQ             [ reduce using rule 43 (binary_operation -> expression NEQ expression .) ]
  ! L_BKT           [ shift and go to state 27 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 68

    (44) binary_operation -> expression LT expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 44 (binary_operation -> expression LT expression .)
    L_BKT           reduce using rule 44 (binary_operation -> expression LT expression .)
    EQ              reduce using rule 44 (binary_operation -> expression LT expression .)
    NEQ             reduce using rule 44 (binary_operation -> expression LT expression .)
    LT              reduce using rule 44 (binary_operation -> expression LT expression .)
    GT              reduce using rule 44 (binary_operation -> expression LT expression .)
    LEQ             reduce using rule 44 (binary_operation -> expression LT expression .)
    GEQ             reduce using rule 44 (binary_operation -> expression LT expression .)
    OR              reduce using rule 44 (binary_operation -> expression LT expression .)
    AND             reduce using rule 44 (binary_operation -> expression LT expression .)
    L_PAR           reduce using rule 44 (binary_operation -> expression LT expression .)
    R_PAR           reduce using rule 44 (binary_operation -> expression LT expression .)
    COMMA           reduce using rule 44 (binary_operation -> expression LT expression .)
    R_BKT           reduce using rule 44 (binary_operation -> expression LT expression .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32

  ! PLUS            [ reduce using rule 44 (binary_operation -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 44 (binary_operation -> expression LT expression .) ]
  ! MULTIPLY        [ reduce using rule 44 (binary_operation -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 44 (binary_operation -> expression LT expression .) ]
  ! MODULO          [ reduce using rule 44 (binary_operation -> expression LT expression .) ]
  ! L_BKT           [ shift and go to state 27 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! LT              [ shift and go to state 35 ]
  ! GT              [ shift and go to state 36 ]
  ! LEQ             [ shift and go to state 37 ]
  ! GEQ             [ shift and go to state 38 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 69

    (45) binary_operation -> expression GT expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 45 (binary_operation -> expression GT expression .)
    L_BKT           reduce using rule 45 (binary_operation -> expression GT expression .)
    EQ              reduce using rule 45 (binary_operation -> expression GT expression .)
    NEQ             reduce using rule 45 (binary_operation -> expression GT expression .)
    LT              reduce using rule 45 (binary_operation -> expression GT expression .)
    GT              reduce using rule 45 (binary_operation -> expression GT expression .)
    LEQ             reduce using rule 45 (binary_operation -> expression GT expression .)
    GEQ             reduce using rule 45 (binary_operation -> expression GT expression .)
    OR              reduce using rule 45 (binary_operation -> expression GT expression .)
    AND             reduce using rule 45 (binary_operation -> expression GT expression .)
    L_PAR           reduce using rule 45 (binary_operation -> expression GT expression .)
    R_PAR           reduce using rule 45 (binary_operation -> expression GT expression .)
    COMMA           reduce using rule 45 (binary_operation -> expression GT expression .)
    R_BKT           reduce using rule 45 (binary_operation -> expression GT expression .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32

  ! PLUS            [ reduce using rule 45 (binary_operation -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 45 (binary_operation -> expression GT expression .) ]
  ! MULTIPLY        [ reduce using rule 45 (binary_operation -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 45 (binary_operation -> expression GT expression .) ]
  ! MODULO          [ reduce using rule 45 (binary_operation -> expression GT expression .) ]
  ! L_BKT           [ shift and go to state 27 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! LT              [ shift and go to state 35 ]
  ! GT              [ shift and go to state 36 ]
  ! LEQ             [ shift and go to state 37 ]
  ! GEQ             [ shift and go to state 38 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 70

    (46) binary_operation -> expression LEQ expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 46 (binary_operation -> expression LEQ expression .)
    L_BKT           reduce using rule 46 (binary_operation -> expression LEQ expression .)
    EQ              reduce using rule 46 (binary_operation -> expression LEQ expression .)
    NEQ             reduce using rule 46 (binary_operation -> expression LEQ expression .)
    LT              reduce using rule 46 (binary_operation -> expression LEQ expression .)
    GT              reduce using rule 46 (binary_operation -> expression LEQ expression .)
    LEQ             reduce using rule 46 (binary_operation -> expression LEQ expression .)
    GEQ             reduce using rule 46 (binary_operation -> expression LEQ expression .)
    OR              reduce using rule 46 (binary_operation -> expression LEQ expression .)
    AND             reduce using rule 46 (binary_operation -> expression LEQ expression .)
    L_PAR           reduce using rule 46 (binary_operation -> expression LEQ expression .)
    R_PAR           reduce using rule 46 (binary_operation -> expression LEQ expression .)
    COMMA           reduce using rule 46 (binary_operation -> expression LEQ expression .)
    R_BKT           reduce using rule 46 (binary_operation -> expression LEQ expression .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32

  ! PLUS            [ reduce using rule 46 (binary_operation -> expression LEQ expression .) ]
  ! MINUS           [ reduce using rule 46 (binary_operation -> expression LEQ expression .) ]
  ! MULTIPLY        [ reduce using rule 46 (binary_operation -> expression LEQ expression .) ]
  ! DIVIDE          [ reduce using rule 46 (binary_operation -> expression LEQ expression .) ]
  ! MODULO          [ reduce using rule 46 (binary_operation -> expression LEQ expression .) ]
  ! L_BKT           [ shift and go to state 27 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! LT              [ shift and go to state 35 ]
  ! GT              [ shift and go to state 36 ]
  ! LEQ             [ shift and go to state 37 ]
  ! GEQ             [ shift and go to state 38 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 71

    (47) binary_operation -> expression GEQ expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 47 (binary_operation -> expression GEQ expression .)
    L_BKT           reduce using rule 47 (binary_operation -> expression GEQ expression .)
    EQ              reduce using rule 47 (binary_operation -> expression GEQ expression .)
    NEQ             reduce using rule 47 (binary_operation -> expression GEQ expression .)
    LT              reduce using rule 47 (binary_operation -> expression GEQ expression .)
    GT              reduce using rule 47 (binary_operation -> expression GEQ expression .)
    LEQ             reduce using rule 47 (binary_operation -> expression GEQ expression .)
    GEQ             reduce using rule 47 (binary_operation -> expression GEQ expression .)
    OR              reduce using rule 47 (binary_operation -> expression GEQ expression .)
    AND             reduce using rule 47 (binary_operation -> expression GEQ expression .)
    L_PAR           reduce using rule 47 (binary_operation -> expression GEQ expression .)
    R_PAR           reduce using rule 47 (binary_operation -> expression GEQ expression .)
    COMMA           reduce using rule 47 (binary_operation -> expression GEQ expression .)
    R_BKT           reduce using rule 47 (binary_operation -> expression GEQ expression .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32

  ! PLUS            [ reduce using rule 47 (binary_operation -> expression GEQ expression .) ]
  ! MINUS           [ reduce using rule 47 (binary_operation -> expression GEQ expression .) ]
  ! MULTIPLY        [ reduce using rule 47 (binary_operation -> expression GEQ expression .) ]
  ! DIVIDE          [ reduce using rule 47 (binary_operation -> expression GEQ expression .) ]
  ! MODULO          [ reduce using rule 47 (binary_operation -> expression GEQ expression .) ]
  ! L_BKT           [ shift and go to state 27 ]
  ! EQ              [ shift and go to state 33 ]
  ! NEQ             [ shift and go to state 34 ]
  ! LT              [ shift and go to state 35 ]
  ! GT              [ shift and go to state 36 ]
  ! LEQ             [ shift and go to state 37 ]
  ! GEQ             [ shift and go to state 38 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 72

    (48) binary_operation -> expression OR expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 48 (binary_operation -> expression OR expression .)
    L_BKT           reduce using rule 48 (binary_operation -> expression OR expression .)
    OR              reduce using rule 48 (binary_operation -> expression OR expression .)
    AND             reduce using rule 48 (binary_operation -> expression OR expression .)
    L_PAR           reduce using rule 48 (binary_operation -> expression OR expression .)
    R_PAR           reduce using rule 48 (binary_operation -> expression OR expression .)
    COMMA           reduce using rule 48 (binary_operation -> expression OR expression .)
    R_BKT           reduce using rule 48 (binary_operation -> expression OR expression .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    EQ              shift and go to state 33
    NEQ             shift and go to state 34
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38

  ! PLUS            [ reduce using rule 48 (binary_operation -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 48 (binary_operation -> expression OR expression .) ]
  ! MULTIPLY        [ reduce using rule 48 (binary_operation -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 48 (binary_operation -> expression OR expression .) ]
  ! MODULO          [ reduce using rule 48 (binary_operation -> expression OR expression .) ]
  ! EQ              [ reduce using rule 48 (binary_operation -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 48 (binary_operation -> expression OR expression .) ]
  ! LT              [ reduce using rule 48 (binary_operation -> expression OR expression .) ]
  ! GT              [ reduce using rule 48 (binary_operation -> expression OR expression .) ]
  ! LEQ             [ reduce using rule 48 (binary_operation -> expression OR expression .) ]
  ! GEQ             [ reduce using rule 48 (binary_operation -> expression OR expression .) ]
  ! L_BKT           [ shift and go to state 27 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 73

    (49) binary_operation -> expression AND expression .
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 49 (binary_operation -> expression AND expression .)
    L_BKT           reduce using rule 49 (binary_operation -> expression AND expression .)
    OR              reduce using rule 49 (binary_operation -> expression AND expression .)
    AND             reduce using rule 49 (binary_operation -> expression AND expression .)
    L_PAR           reduce using rule 49 (binary_operation -> expression AND expression .)
    R_PAR           reduce using rule 49 (binary_operation -> expression AND expression .)
    COMMA           reduce using rule 49 (binary_operation -> expression AND expression .)
    R_BKT           reduce using rule 49 (binary_operation -> expression AND expression .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    EQ              shift and go to state 33
    NEQ             shift and go to state 34
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38

  ! PLUS            [ reduce using rule 49 (binary_operation -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 49 (binary_operation -> expression AND expression .) ]
  ! MULTIPLY        [ reduce using rule 49 (binary_operation -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 49 (binary_operation -> expression AND expression .) ]
  ! MODULO          [ reduce using rule 49 (binary_operation -> expression AND expression .) ]
  ! EQ              [ reduce using rule 49 (binary_operation -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 49 (binary_operation -> expression AND expression .) ]
  ! LT              [ reduce using rule 49 (binary_operation -> expression AND expression .) ]
  ! GT              [ reduce using rule 49 (binary_operation -> expression AND expression .) ]
  ! LEQ             [ reduce using rule 49 (binary_operation -> expression AND expression .) ]
  ! GEQ             [ reduce using rule 49 (binary_operation -> expression AND expression .) ]
  ! L_BKT           [ shift and go to state 27 ]
  ! OR              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 40 ]
  ! L_PAR           [ shift and go to state 41 ]


state 74

    (59) function_call -> expression L_PAR R_PAR .

    SEMI            reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    L_BKT           reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    PLUS            reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    MINUS           reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    MULTIPLY        reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    DIVIDE          reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    MODULO          reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    EQ              reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    NEQ             reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    LT              reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    GT              reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    LEQ             reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    GEQ             reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    OR              reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    AND             reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    L_PAR           reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    R_PAR           reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    COMMA           reduce using rule 59 (function_call -> expression L_PAR R_PAR .)
    R_BKT           reduce using rule 59 (function_call -> expression L_PAR R_PAR .)


state 75

    (60) function_call -> expression L_PAR arg_list . R_PAR

    R_PAR           shift and go to state 94


state 76

    (14) statement -> IDEN ASSIGN expression . SEMI
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 95
    L_BKT           shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    EQ              shift and go to state 33
    NEQ             shift and go to state 34
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38
    OR              shift and go to state 39
    AND             shift and go to state 40
    L_PAR           shift and go to state 41


state 77

    (15) statement -> LET IDEN SEMI .

    IDEN            reduce using rule 15 (statement -> LET IDEN SEMI .)
    LET             reduce using rule 15 (statement -> LET IDEN SEMI .)
    RETURN          reduce using rule 15 (statement -> LET IDEN SEMI .)
    IF              reduce using rule 15 (statement -> LET IDEN SEMI .)
    WHILE           reduce using rule 15 (statement -> LET IDEN SEMI .)
    L_BRC           reduce using rule 15 (statement -> LET IDEN SEMI .)
    BREAK           reduce using rule 15 (statement -> LET IDEN SEMI .)
    CONTINUE        reduce using rule 15 (statement -> LET IDEN SEMI .)
    L_PAR           reduce using rule 15 (statement -> LET IDEN SEMI .)
    NUM_LIT         reduce using rule 15 (statement -> LET IDEN SEMI .)
    BOOL_LIT        reduce using rule 15 (statement -> LET IDEN SEMI .)
    STR_LIT         reduce using rule 15 (statement -> LET IDEN SEMI .)
    L_BKT           reduce using rule 15 (statement -> LET IDEN SEMI .)
    PLUS            reduce using rule 15 (statement -> LET IDEN SEMI .)
    MINUS           reduce using rule 15 (statement -> LET IDEN SEMI .)
    NOT             reduce using rule 15 (statement -> LET IDEN SEMI .)
    $end            reduce using rule 15 (statement -> LET IDEN SEMI .)
    R_BRC           reduce using rule 15 (statement -> LET IDEN SEMI .)
    ELSE            reduce using rule 15 (statement -> LET IDEN SEMI .)


state 78

    (16) statement -> LET IDEN COLON . type SEMI
    (18) statement -> LET IDEN COLON . type ASSIGN expression SEMI
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . VOID
    (7) type -> . type ARROW type
    (8) type -> . L_PAR typelist R_PAR

    NUMBER          shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99
    ANY             shift and go to state 100
    VOID            shift and go to state 101
    L_PAR           shift and go to state 102

    type                           shift and go to state 96

state 79

    (17) statement -> LET IDEN ASSIGN . expression SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 103
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 80

    (19) statement -> RETURN expression SEMI .

    IDEN            reduce using rule 19 (statement -> RETURN expression SEMI .)
    LET             reduce using rule 19 (statement -> RETURN expression SEMI .)
    RETURN          reduce using rule 19 (statement -> RETURN expression SEMI .)
    IF              reduce using rule 19 (statement -> RETURN expression SEMI .)
    WHILE           reduce using rule 19 (statement -> RETURN expression SEMI .)
    L_BRC           reduce using rule 19 (statement -> RETURN expression SEMI .)
    BREAK           reduce using rule 19 (statement -> RETURN expression SEMI .)
    CONTINUE        reduce using rule 19 (statement -> RETURN expression SEMI .)
    L_PAR           reduce using rule 19 (statement -> RETURN expression SEMI .)
    NUM_LIT         reduce using rule 19 (statement -> RETURN expression SEMI .)
    BOOL_LIT        reduce using rule 19 (statement -> RETURN expression SEMI .)
    STR_LIT         reduce using rule 19 (statement -> RETURN expression SEMI .)
    L_BKT           reduce using rule 19 (statement -> RETURN expression SEMI .)
    PLUS            reduce using rule 19 (statement -> RETURN expression SEMI .)
    MINUS           reduce using rule 19 (statement -> RETURN expression SEMI .)
    NOT             reduce using rule 19 (statement -> RETURN expression SEMI .)
    $end            reduce using rule 19 (statement -> RETURN expression SEMI .)
    R_BRC           reduce using rule 19 (statement -> RETURN expression SEMI .)
    ELSE            reduce using rule 19 (statement -> RETURN expression SEMI .)


state 81

    (20) statement -> IF L_PAR expression . R_PAR statement ELSE statement
    (21) statement -> IF L_PAR expression . R_PAR statement
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    R_PAR           shift and go to state 104
    L_BKT           shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    EQ              shift and go to state 33
    NEQ             shift and go to state 34
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38
    OR              shift and go to state 39
    AND             shift and go to state 40
    L_PAR           shift and go to state 41


state 82

    (28) expression -> L_PAR expression R_PAR .

    SEMI            reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    L_BKT           reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    PLUS            reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    MINUS           reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    MULTIPLY        reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    DIVIDE          reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    MODULO          reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    EQ              reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    NEQ             reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    LT              reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    GT              reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    LEQ             reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    GEQ             reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    OR              reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    AND             reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    L_PAR           reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    R_PAR           reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    COMMA           reduce using rule 28 (expression -> L_PAR expression R_PAR .)
    R_BKT           reduce using rule 28 (expression -> L_PAR expression R_PAR .)


state 83

    (61) lambda -> L_PAR R_PAR ARROW . L_BRC block R_BRC

    L_BRC           shift and go to state 105


state 84

    (62) lambda -> L_PAR R_PAR COLON . type ARROW L_BRC block R_BRC
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . VOID
    (7) type -> . type ARROW type
    (8) type -> . L_PAR typelist R_PAR

    NUMBER          shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99
    ANY             shift and go to state 100
    VOID            shift and go to state 101
    L_PAR           shift and go to state 102

    type                           shift and go to state 106

state 85

    (63) lambda -> L_PAR IDEN R_PAR . ARROW L_BRC block R_BRC
    (64) lambda -> L_PAR IDEN R_PAR . COLON type ARROW L_BRC block R_BRC

    ARROW           shift and go to state 107
    COLON           shift and go to state 108


state 86

    (56) param_list -> IDEN COLON . type COMMA param_list
    (58) param_list -> IDEN COLON . type
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . VOID
    (7) type -> . type ARROW type
    (8) type -> . L_PAR typelist R_PAR

    NUMBER          shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99
    ANY             shift and go to state 100
    VOID            shift and go to state 101
    L_PAR           shift and go to state 102

    type                           shift and go to state 109

state 87

    (55) param_list -> IDEN COMMA . param_list
    (55) param_list -> . IDEN COMMA param_list
    (56) param_list -> . IDEN COLON type COMMA param_list
    (57) param_list -> . IDEN
    (58) param_list -> . IDEN COLON type

    IDEN            shift and go to state 110

    param_list                     shift and go to state 111

state 88

    (65) lambda -> L_PAR param_list R_PAR . ARROW L_BRC block R_BRC
    (66) lambda -> L_PAR param_list R_PAR . COLON type ARROW L_BRC block R_BRC

    ARROW           shift and go to state 112
    COLON           shift and go to state 113


state 89

    (22) statement -> WHILE L_PAR expression . R_PAR statement
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    R_PAR           shift and go to state 114
    L_BKT           shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    EQ              shift and go to state 33
    NEQ             shift and go to state 34
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38
    OR              shift and go to state 39
    AND             shift and go to state 40
    L_PAR           shift and go to state 41


state 90

    (23) statement -> L_BRC block R_BRC .

    IDEN            reduce using rule 23 (statement -> L_BRC block R_BRC .)
    LET             reduce using rule 23 (statement -> L_BRC block R_BRC .)
    RETURN          reduce using rule 23 (statement -> L_BRC block R_BRC .)
    IF              reduce using rule 23 (statement -> L_BRC block R_BRC .)
    WHILE           reduce using rule 23 (statement -> L_BRC block R_BRC .)
    L_BRC           reduce using rule 23 (statement -> L_BRC block R_BRC .)
    BREAK           reduce using rule 23 (statement -> L_BRC block R_BRC .)
    CONTINUE        reduce using rule 23 (statement -> L_BRC block R_BRC .)
    L_PAR           reduce using rule 23 (statement -> L_BRC block R_BRC .)
    NUM_LIT         reduce using rule 23 (statement -> L_BRC block R_BRC .)
    BOOL_LIT        reduce using rule 23 (statement -> L_BRC block R_BRC .)
    STR_LIT         reduce using rule 23 (statement -> L_BRC block R_BRC .)
    L_BKT           reduce using rule 23 (statement -> L_BRC block R_BRC .)
    PLUS            reduce using rule 23 (statement -> L_BRC block R_BRC .)
    MINUS           reduce using rule 23 (statement -> L_BRC block R_BRC .)
    NOT             reduce using rule 23 (statement -> L_BRC block R_BRC .)
    $end            reduce using rule 23 (statement -> L_BRC block R_BRC .)
    R_BRC           reduce using rule 23 (statement -> L_BRC block R_BRC .)
    ELSE            reduce using rule 23 (statement -> L_BRC block R_BRC .)


state 91

    (35) expression -> L_BKT arg_list R_BKT .

    SEMI            reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    L_BKT           reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    PLUS            reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    MINUS           reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    MULTIPLY        reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    DIVIDE          reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    MODULO          reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    EQ              reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    NEQ             reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    LT              reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    GT              reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    LEQ             reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    GEQ             reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    OR              reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    AND             reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    L_PAR           reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    R_PAR           reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    COMMA           reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)
    R_BKT           reduce using rule 35 (expression -> L_BKT arg_list R_BKT .)


state 92

    (54) arg_list -> expression COMMA . arg_list
    (53) arg_list -> . expression
    (54) arg_list -> . expression COMMA arg_list
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 56
    arg_list                       shift and go to state 115
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 93

    (36) expression -> expression L_BKT expression R_BKT .

    SEMI            reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    L_BKT           reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    PLUS            reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    MINUS           reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    MULTIPLY        reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    DIVIDE          reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    MODULO          reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    EQ              reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    NEQ             reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    LT              reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    GT              reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    LEQ             reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    GEQ             reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    OR              reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    AND             reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    L_PAR           reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    R_PAR           reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    COMMA           reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)
    R_BKT           reduce using rule 36 (expression -> expression L_BKT expression R_BKT .)


state 94

    (60) function_call -> expression L_PAR arg_list R_PAR .

    SEMI            reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    L_BKT           reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    PLUS            reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    MINUS           reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    MULTIPLY        reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    DIVIDE          reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    MODULO          reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    EQ              reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    NEQ             reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    LT              reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    GT              reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    LEQ             reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    GEQ             reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    OR              reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    AND             reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    L_PAR           reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    R_PAR           reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    COMMA           reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)
    R_BKT           reduce using rule 60 (function_call -> expression L_PAR arg_list R_PAR .)


state 95

    (14) statement -> IDEN ASSIGN expression SEMI .

    IDEN            reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    LET             reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    RETURN          reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    IF              reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    WHILE           reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    L_BRC           reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    BREAK           reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    CONTINUE        reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    L_PAR           reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    NUM_LIT         reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    BOOL_LIT        reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    STR_LIT         reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    L_BKT           reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    PLUS            reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    MINUS           reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    NOT             reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    $end            reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    R_BRC           reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)
    ELSE            reduce using rule 14 (statement -> IDEN ASSIGN expression SEMI .)


state 96

    (16) statement -> LET IDEN COLON type . SEMI
    (18) statement -> LET IDEN COLON type . ASSIGN expression SEMI
    (7) type -> type . ARROW type

    SEMI            shift and go to state 116
    ASSIGN          shift and go to state 117
    ARROW           shift and go to state 118


state 97

    (2) type -> NUMBER .

    SEMI            reduce using rule 2 (type -> NUMBER .)
    ASSIGN          reduce using rule 2 (type -> NUMBER .)
    ARROW           reduce using rule 2 (type -> NUMBER .)
    COMMA           reduce using rule 2 (type -> NUMBER .)
    R_PAR           reduce using rule 2 (type -> NUMBER .)


state 98

    (3) type -> BOOL .

    SEMI            reduce using rule 3 (type -> BOOL .)
    ASSIGN          reduce using rule 3 (type -> BOOL .)
    ARROW           reduce using rule 3 (type -> BOOL .)
    COMMA           reduce using rule 3 (type -> BOOL .)
    R_PAR           reduce using rule 3 (type -> BOOL .)


state 99

    (4) type -> STRING .

    SEMI            reduce using rule 4 (type -> STRING .)
    ASSIGN          reduce using rule 4 (type -> STRING .)
    ARROW           reduce using rule 4 (type -> STRING .)
    COMMA           reduce using rule 4 (type -> STRING .)
    R_PAR           reduce using rule 4 (type -> STRING .)


state 100

    (5) type -> ANY .

    SEMI            reduce using rule 5 (type -> ANY .)
    ASSIGN          reduce using rule 5 (type -> ANY .)
    ARROW           reduce using rule 5 (type -> ANY .)
    COMMA           reduce using rule 5 (type -> ANY .)
    R_PAR           reduce using rule 5 (type -> ANY .)


state 101

    (6) type -> VOID .

    SEMI            reduce using rule 6 (type -> VOID .)
    ASSIGN          reduce using rule 6 (type -> VOID .)
    ARROW           reduce using rule 6 (type -> VOID .)
    COMMA           reduce using rule 6 (type -> VOID .)
    R_PAR           reduce using rule 6 (type -> VOID .)


state 102

    (8) type -> L_PAR . typelist R_PAR
    (9) typelist -> . type COMMA typelist
    (10) typelist -> . type
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . VOID
    (7) type -> . type ARROW type
    (8) type -> . L_PAR typelist R_PAR

    NUMBER          shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99
    ANY             shift and go to state 100
    VOID            shift and go to state 101
    L_PAR           shift and go to state 102

    typelist                       shift and go to state 119
    type                           shift and go to state 120

state 103

    (17) statement -> LET IDEN ASSIGN expression . SEMI
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 121
    L_BKT           shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    EQ              shift and go to state 33
    NEQ             shift and go to state 34
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38
    OR              shift and go to state 39
    AND             shift and go to state 40
    L_PAR           shift and go to state 41


state 104

    (20) statement -> IF L_PAR expression R_PAR . statement ELSE statement
    (21) statement -> IF L_PAR expression R_PAR . statement
    (13) statement -> . expression SEMI
    (14) statement -> . IDEN ASSIGN expression SEMI
    (15) statement -> . LET IDEN SEMI
    (16) statement -> . LET IDEN COLON type SEMI
    (17) statement -> . LET IDEN ASSIGN expression SEMI
    (18) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (19) statement -> . RETURN expression SEMI
    (20) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (21) statement -> . IF L_PAR expression R_PAR statement
    (22) statement -> . WHILE L_PAR expression R_PAR statement
    (23) statement -> . L_BRC block R_BRC
    (24) statement -> . BREAK SEMI
    (25) statement -> . CONTINUE SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 4
    statement                      shift and go to state 122
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 105

    (61) lambda -> L_PAR R_PAR ARROW L_BRC . block R_BRC
    (11) block -> . statement
    (12) block -> . statement block
    (13) statement -> . expression SEMI
    (14) statement -> . IDEN ASSIGN expression SEMI
    (15) statement -> . LET IDEN SEMI
    (16) statement -> . LET IDEN COLON type SEMI
    (17) statement -> . LET IDEN ASSIGN expression SEMI
    (18) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (19) statement -> . RETURN expression SEMI
    (20) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (21) statement -> . IF L_PAR expression R_PAR statement
    (22) statement -> . WHILE L_PAR expression R_PAR statement
    (23) statement -> . L_BRC block R_BRC
    (24) statement -> . BREAK SEMI
    (25) statement -> . CONTINUE SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    block                          shift and go to state 123
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 106

    (62) lambda -> L_PAR R_PAR COLON type . ARROW L_BRC block R_BRC
    (7) type -> type . ARROW type

    ARROW           shift and go to state 124


state 107

    (63) lambda -> L_PAR IDEN R_PAR ARROW . L_BRC block R_BRC

    L_BRC           shift and go to state 125


state 108

    (64) lambda -> L_PAR IDEN R_PAR COLON . type ARROW L_BRC block R_BRC
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . VOID
    (7) type -> . type ARROW type
    (8) type -> . L_PAR typelist R_PAR

    NUMBER          shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99
    ANY             shift and go to state 100
    VOID            shift and go to state 101
    L_PAR           shift and go to state 102

    type                           shift and go to state 126

state 109

    (56) param_list -> IDEN COLON type . COMMA param_list
    (58) param_list -> IDEN COLON type .
    (7) type -> type . ARROW type

    COMMA           shift and go to state 127
    R_PAR           reduce using rule 58 (param_list -> IDEN COLON type .)
    ARROW           shift and go to state 118


state 110

    (55) param_list -> IDEN . COMMA param_list
    (56) param_list -> IDEN . COLON type COMMA param_list
    (57) param_list -> IDEN .
    (58) param_list -> IDEN . COLON type

    COMMA           shift and go to state 87
    COLON           shift and go to state 86
    R_PAR           reduce using rule 57 (param_list -> IDEN .)


state 111

    (55) param_list -> IDEN COMMA param_list .

    R_PAR           reduce using rule 55 (param_list -> IDEN COMMA param_list .)


state 112

    (65) lambda -> L_PAR param_list R_PAR ARROW . L_BRC block R_BRC

    L_BRC           shift and go to state 128


state 113

    (66) lambda -> L_PAR param_list R_PAR COLON . type ARROW L_BRC block R_BRC
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . VOID
    (7) type -> . type ARROW type
    (8) type -> . L_PAR typelist R_PAR

    NUMBER          shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99
    ANY             shift and go to state 100
    VOID            shift and go to state 101
    L_PAR           shift and go to state 102

    type                           shift and go to state 129

state 114

    (22) statement -> WHILE L_PAR expression R_PAR . statement
    (13) statement -> . expression SEMI
    (14) statement -> . IDEN ASSIGN expression SEMI
    (15) statement -> . LET IDEN SEMI
    (16) statement -> . LET IDEN COLON type SEMI
    (17) statement -> . LET IDEN ASSIGN expression SEMI
    (18) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (19) statement -> . RETURN expression SEMI
    (20) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (21) statement -> . IF L_PAR expression R_PAR statement
    (22) statement -> . WHILE L_PAR expression R_PAR statement
    (23) statement -> . L_BRC block R_BRC
    (24) statement -> . BREAK SEMI
    (25) statement -> . CONTINUE SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 4
    statement                      shift and go to state 130
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 115

    (54) arg_list -> expression COMMA arg_list .

    R_BKT           reduce using rule 54 (arg_list -> expression COMMA arg_list .)
    R_PAR           reduce using rule 54 (arg_list -> expression COMMA arg_list .)


state 116

    (16) statement -> LET IDEN COLON type SEMI .

    IDEN            reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    LET             reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    RETURN          reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    IF              reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    WHILE           reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    L_BRC           reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    BREAK           reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    CONTINUE        reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    L_PAR           reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    NUM_LIT         reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    BOOL_LIT        reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    STR_LIT         reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    L_BKT           reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    PLUS            reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    MINUS           reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    NOT             reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    $end            reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    R_BRC           reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)
    ELSE            reduce using rule 16 (statement -> LET IDEN COLON type SEMI .)


state 117

    (18) statement -> LET IDEN COLON type ASSIGN . expression SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 45
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 131
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 118

    (7) type -> type ARROW . type
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . VOID
    (7) type -> . type ARROW type
    (8) type -> . L_PAR typelist R_PAR

    NUMBER          shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99
    ANY             shift and go to state 100
    VOID            shift and go to state 101
    L_PAR           shift and go to state 102

    type                           shift and go to state 132

state 119

    (8) type -> L_PAR typelist . R_PAR

    R_PAR           shift and go to state 133


state 120

    (9) typelist -> type . COMMA typelist
    (10) typelist -> type .
    (7) type -> type . ARROW type

    COMMA           shift and go to state 134
    R_PAR           reduce using rule 10 (typelist -> type .)
    ARROW           shift and go to state 118


state 121

    (17) statement -> LET IDEN ASSIGN expression SEMI .

    IDEN            reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    LET             reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    RETURN          reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    IF              reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    WHILE           reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    L_BRC           reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    BREAK           reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    CONTINUE        reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    L_PAR           reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    NUM_LIT         reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    BOOL_LIT        reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    STR_LIT         reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    L_BKT           reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    PLUS            reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    MINUS           reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    NOT             reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    $end            reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    R_BRC           reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)
    ELSE            reduce using rule 17 (statement -> LET IDEN ASSIGN expression SEMI .)


state 122

    (20) statement -> IF L_PAR expression R_PAR statement . ELSE statement
    (21) statement -> IF L_PAR expression R_PAR statement .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 135
    IDEN            reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    LET             reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    RETURN          reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    IF              reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    WHILE           reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    L_BRC           reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    BREAK           reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    CONTINUE        reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    L_PAR           reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    NUM_LIT         reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    BOOL_LIT        reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    STR_LIT         reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    L_BKT           reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    PLUS            reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    MINUS           reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    NOT             reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    $end            reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)
    R_BRC           reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .)

  ! ELSE            [ reduce using rule 21 (statement -> IF L_PAR expression R_PAR statement .) ]


state 123

    (61) lambda -> L_PAR R_PAR ARROW L_BRC block . R_BRC

    R_BRC           shift and go to state 136


state 124

    (62) lambda -> L_PAR R_PAR COLON type ARROW . L_BRC block R_BRC
    (7) type -> type ARROW . type
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . VOID
    (7) type -> . type ARROW type
    (8) type -> . L_PAR typelist R_PAR

    L_BRC           shift and go to state 137
    NUMBER          shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99
    ANY             shift and go to state 100
    VOID            shift and go to state 101
    L_PAR           shift and go to state 102

    type                           shift and go to state 132

state 125

    (63) lambda -> L_PAR IDEN R_PAR ARROW L_BRC . block R_BRC
    (11) block -> . statement
    (12) block -> . statement block
    (13) statement -> . expression SEMI
    (14) statement -> . IDEN ASSIGN expression SEMI
    (15) statement -> . LET IDEN SEMI
    (16) statement -> . LET IDEN COLON type SEMI
    (17) statement -> . LET IDEN ASSIGN expression SEMI
    (18) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (19) statement -> . RETURN expression SEMI
    (20) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (21) statement -> . IF L_PAR expression R_PAR statement
    (22) statement -> . WHILE L_PAR expression R_PAR statement
    (23) statement -> . L_BRC block R_BRC
    (24) statement -> . BREAK SEMI
    (25) statement -> . CONTINUE SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    block                          shift and go to state 138
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 126

    (64) lambda -> L_PAR IDEN R_PAR COLON type . ARROW L_BRC block R_BRC
    (7) type -> type . ARROW type

    ARROW           shift and go to state 139


state 127

    (56) param_list -> IDEN COLON type COMMA . param_list
    (55) param_list -> . IDEN COMMA param_list
    (56) param_list -> . IDEN COLON type COMMA param_list
    (57) param_list -> . IDEN
    (58) param_list -> . IDEN COLON type

    IDEN            shift and go to state 110

    param_list                     shift and go to state 140

state 128

    (65) lambda -> L_PAR param_list R_PAR ARROW L_BRC . block R_BRC
    (11) block -> . statement
    (12) block -> . statement block
    (13) statement -> . expression SEMI
    (14) statement -> . IDEN ASSIGN expression SEMI
    (15) statement -> . LET IDEN SEMI
    (16) statement -> . LET IDEN COLON type SEMI
    (17) statement -> . LET IDEN ASSIGN expression SEMI
    (18) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (19) statement -> . RETURN expression SEMI
    (20) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (21) statement -> . IF L_PAR expression R_PAR statement
    (22) statement -> . WHILE L_PAR expression R_PAR statement
    (23) statement -> . L_BRC block R_BRC
    (24) statement -> . BREAK SEMI
    (25) statement -> . CONTINUE SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    block                          shift and go to state 141
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 129

    (66) lambda -> L_PAR param_list R_PAR COLON type . ARROW L_BRC block R_BRC
    (7) type -> type . ARROW type

    ARROW           shift and go to state 142


state 130

    (22) statement -> WHILE L_PAR expression R_PAR statement .

    IDEN            reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    LET             reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    RETURN          reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    IF              reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    WHILE           reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    L_BRC           reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    BREAK           reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    CONTINUE        reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    L_PAR           reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    NUM_LIT         reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    BOOL_LIT        reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    STR_LIT         reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    L_BKT           reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    PLUS            reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    MINUS           reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    NOT             reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    $end            reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    R_BRC           reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)
    ELSE            reduce using rule 22 (statement -> WHILE L_PAR expression R_PAR statement .)


state 131

    (18) statement -> LET IDEN COLON type ASSIGN expression . SEMI
    (36) expression -> expression . L_BKT expression R_BKT
    (37) binary_operation -> expression . PLUS expression
    (38) binary_operation -> expression . MINUS expression
    (39) binary_operation -> expression . MULTIPLY expression
    (40) binary_operation -> expression . DIVIDE expression
    (41) binary_operation -> expression . MODULO expression
    (42) binary_operation -> expression . EQ expression
    (43) binary_operation -> expression . NEQ expression
    (44) binary_operation -> expression . LT expression
    (45) binary_operation -> expression . GT expression
    (46) binary_operation -> expression . LEQ expression
    (47) binary_operation -> expression . GEQ expression
    (48) binary_operation -> expression . OR expression
    (49) binary_operation -> expression . AND expression
    (59) function_call -> expression . L_PAR R_PAR
    (60) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 143
    L_BKT           shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    MULTIPLY        shift and go to state 30
    DIVIDE          shift and go to state 31
    MODULO          shift and go to state 32
    EQ              shift and go to state 33
    NEQ             shift and go to state 34
    LT              shift and go to state 35
    GT              shift and go to state 36
    LEQ             shift and go to state 37
    GEQ             shift and go to state 38
    OR              shift and go to state 39
    AND             shift and go to state 40
    L_PAR           shift and go to state 41


state 132

    (7) type -> type ARROW type .
    (7) type -> type . ARROW type

  ! shift/reduce conflict for ARROW resolved as shift
    SEMI            reduce using rule 7 (type -> type ARROW type .)
    ASSIGN          reduce using rule 7 (type -> type ARROW type .)
    COMMA           reduce using rule 7 (type -> type ARROW type .)
    R_PAR           reduce using rule 7 (type -> type ARROW type .)
    ARROW           shift and go to state 118

  ! ARROW           [ reduce using rule 7 (type -> type ARROW type .) ]


state 133

    (8) type -> L_PAR typelist R_PAR .

    SEMI            reduce using rule 8 (type -> L_PAR typelist R_PAR .)
    ASSIGN          reduce using rule 8 (type -> L_PAR typelist R_PAR .)
    ARROW           reduce using rule 8 (type -> L_PAR typelist R_PAR .)
    COMMA           reduce using rule 8 (type -> L_PAR typelist R_PAR .)
    R_PAR           reduce using rule 8 (type -> L_PAR typelist R_PAR .)


state 134

    (9) typelist -> type COMMA . typelist
    (9) typelist -> . type COMMA typelist
    (10) typelist -> . type
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . VOID
    (7) type -> . type ARROW type
    (8) type -> . L_PAR typelist R_PAR

    NUMBER          shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99
    ANY             shift and go to state 100
    VOID            shift and go to state 101
    L_PAR           shift and go to state 102

    type                           shift and go to state 120
    typelist                       shift and go to state 144

state 135

    (20) statement -> IF L_PAR expression R_PAR statement ELSE . statement
    (13) statement -> . expression SEMI
    (14) statement -> . IDEN ASSIGN expression SEMI
    (15) statement -> . LET IDEN SEMI
    (16) statement -> . LET IDEN COLON type SEMI
    (17) statement -> . LET IDEN ASSIGN expression SEMI
    (18) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (19) statement -> . RETURN expression SEMI
    (20) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (21) statement -> . IF L_PAR expression R_PAR statement
    (22) statement -> . WHILE L_PAR expression R_PAR statement
    (23) statement -> . L_BRC block R_BRC
    (24) statement -> . BREAK SEMI
    (25) statement -> . CONTINUE SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    expression                     shift and go to state 4
    statement                      shift and go to state 145
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 136

    (61) lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .

    SEMI            reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    L_BKT           reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    PLUS            reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    MINUS           reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    MULTIPLY        reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    DIVIDE          reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    MODULO          reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    EQ              reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    NEQ             reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    LT              reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    GT              reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    LEQ             reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    GEQ             reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    OR              reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    AND             reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    L_PAR           reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    R_PAR           reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    COMMA           reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    R_BKT           reduce using rule 61 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)


state 137

    (62) lambda -> L_PAR R_PAR COLON type ARROW L_BRC . block R_BRC
    (11) block -> . statement
    (12) block -> . statement block
    (13) statement -> . expression SEMI
    (14) statement -> . IDEN ASSIGN expression SEMI
    (15) statement -> . LET IDEN SEMI
    (16) statement -> . LET IDEN COLON type SEMI
    (17) statement -> . LET IDEN ASSIGN expression SEMI
    (18) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (19) statement -> . RETURN expression SEMI
    (20) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (21) statement -> . IF L_PAR expression R_PAR statement
    (22) statement -> . WHILE L_PAR expression R_PAR statement
    (23) statement -> . L_BRC block R_BRC
    (24) statement -> . BREAK SEMI
    (25) statement -> . CONTINUE SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    block                          shift and go to state 146
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 138

    (63) lambda -> L_PAR IDEN R_PAR ARROW L_BRC block . R_BRC

    R_BRC           shift and go to state 147


state 139

    (64) lambda -> L_PAR IDEN R_PAR COLON type ARROW . L_BRC block R_BRC
    (7) type -> type ARROW . type
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . VOID
    (7) type -> . type ARROW type
    (8) type -> . L_PAR typelist R_PAR

    L_BRC           shift and go to state 148
    NUMBER          shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99
    ANY             shift and go to state 100
    VOID            shift and go to state 101
    L_PAR           shift and go to state 102

    type                           shift and go to state 132

state 140

    (56) param_list -> IDEN COLON type COMMA param_list .

    R_PAR           reduce using rule 56 (param_list -> IDEN COLON type COMMA param_list .)


state 141

    (65) lambda -> L_PAR param_list R_PAR ARROW L_BRC block . R_BRC

    R_BRC           shift and go to state 149


state 142

    (66) lambda -> L_PAR param_list R_PAR COLON type ARROW . L_BRC block R_BRC
    (7) type -> type ARROW . type
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY
    (6) type -> . VOID
    (7) type -> . type ARROW type
    (8) type -> . L_PAR typelist R_PAR

    L_BRC           shift and go to state 150
    NUMBER          shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99
    ANY             shift and go to state 100
    VOID            shift and go to state 101
    L_PAR           shift and go to state 102

    type                           shift and go to state 132

state 143

    (18) statement -> LET IDEN COLON type ASSIGN expression SEMI .

    IDEN            reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    LET             reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    RETURN          reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    IF              reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    WHILE           reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    L_BRC           reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    BREAK           reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    CONTINUE        reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    L_PAR           reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    NUM_LIT         reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    BOOL_LIT        reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    STR_LIT         reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    L_BKT           reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    PLUS            reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    MINUS           reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    NOT             reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    $end            reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    R_BRC           reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    ELSE            reduce using rule 18 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)


state 144

    (9) typelist -> type COMMA typelist .

    R_PAR           reduce using rule 9 (typelist -> type COMMA typelist .)


state 145

    (20) statement -> IF L_PAR expression R_PAR statement ELSE statement .

    IDEN            reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    LET             reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    RETURN          reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    IF              reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    WHILE           reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    L_BRC           reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    BREAK           reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    CONTINUE        reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    L_PAR           reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    NUM_LIT         reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    BOOL_LIT        reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    STR_LIT         reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    L_BKT           reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    PLUS            reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    MINUS           reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    NOT             reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    $end            reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    R_BRC           reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    ELSE            reduce using rule 20 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)


state 146

    (62) lambda -> L_PAR R_PAR COLON type ARROW L_BRC block . R_BRC

    R_BRC           shift and go to state 151


state 147

    (63) lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .

    SEMI            reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    L_BKT           reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    PLUS            reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    MINUS           reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    MULTIPLY        reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    DIVIDE          reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    MODULO          reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    EQ              reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    NEQ             reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    LT              reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    GT              reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    LEQ             reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    GEQ             reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    OR              reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    AND             reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    L_PAR           reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    R_PAR           reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    COMMA           reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    R_BKT           reduce using rule 63 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)


state 148

    (64) lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC . block R_BRC
    (11) block -> . statement
    (12) block -> . statement block
    (13) statement -> . expression SEMI
    (14) statement -> . IDEN ASSIGN expression SEMI
    (15) statement -> . LET IDEN SEMI
    (16) statement -> . LET IDEN COLON type SEMI
    (17) statement -> . LET IDEN ASSIGN expression SEMI
    (18) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (19) statement -> . RETURN expression SEMI
    (20) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (21) statement -> . IF L_PAR expression R_PAR statement
    (22) statement -> . WHILE L_PAR expression R_PAR statement
    (23) statement -> . L_BRC block R_BRC
    (24) statement -> . BREAK SEMI
    (25) statement -> . CONTINUE SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    block                          shift and go to state 152
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 149

    (65) lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .

    SEMI            reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    L_BKT           reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    PLUS            reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    MINUS           reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    MULTIPLY        reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    DIVIDE          reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    MODULO          reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    EQ              reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    NEQ             reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    LT              reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    GT              reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    LEQ             reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    GEQ             reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    OR              reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    AND             reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    L_PAR           reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    R_PAR           reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    COMMA           reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    R_BKT           reduce using rule 65 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)


state 150

    (66) lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC . block R_BRC
    (11) block -> . statement
    (12) block -> . statement block
    (13) statement -> . expression SEMI
    (14) statement -> . IDEN ASSIGN expression SEMI
    (15) statement -> . LET IDEN SEMI
    (16) statement -> . LET IDEN COLON type SEMI
    (17) statement -> . LET IDEN ASSIGN expression SEMI
    (18) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (19) statement -> . RETURN expression SEMI
    (20) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (21) statement -> . IF L_PAR expression R_PAR statement
    (22) statement -> . WHILE L_PAR expression R_PAR statement
    (23) statement -> . L_BRC block R_BRC
    (24) statement -> . BREAK SEMI
    (25) statement -> . CONTINUE SEMI
    (26) expression -> . binary_operation
    (27) expression -> . unary_operation
    (28) expression -> . L_PAR expression R_PAR
    (29) expression -> . NUM_LIT
    (30) expression -> . BOOL_LIT
    (31) expression -> . STR_LIT
    (32) expression -> . function_call
    (33) expression -> . lambda
    (34) expression -> . IDEN
    (35) expression -> . L_BKT arg_list R_BKT
    (36) expression -> . expression L_BKT expression R_BKT
    (37) binary_operation -> . expression PLUS expression
    (38) binary_operation -> . expression MINUS expression
    (39) binary_operation -> . expression MULTIPLY expression
    (40) binary_operation -> . expression DIVIDE expression
    (41) binary_operation -> . expression MODULO expression
    (42) binary_operation -> . expression EQ expression
    (43) binary_operation -> . expression NEQ expression
    (44) binary_operation -> . expression LT expression
    (45) binary_operation -> . expression GT expression
    (46) binary_operation -> . expression LEQ expression
    (47) binary_operation -> . expression GEQ expression
    (48) binary_operation -> . expression OR expression
    (49) binary_operation -> . expression AND expression
    (50) unary_operation -> . PLUS expression
    (51) unary_operation -> . MINUS expression
    (52) unary_operation -> . NOT expression
    (59) function_call -> . expression L_PAR R_PAR
    (60) function_call -> . expression L_PAR arg_list R_PAR
    (61) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (62) lambda -> . L_PAR R_PAR COLON type ARROW L_BRC block R_BRC
    (63) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC
    (64) lambda -> . L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC
    (65) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (66) lambda -> . L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    L_BKT           shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24

    block                          shift and go to state 153
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 151

    (62) lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .

    SEMI            reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    L_BKT           reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    PLUS            reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    MINUS           reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    MULTIPLY        reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    DIVIDE          reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    MODULO          reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    EQ              reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    NEQ             reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    LT              reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    GT              reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    LEQ             reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    GEQ             reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    OR              reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    AND             reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    L_PAR           reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    R_PAR           reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    COMMA           reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)
    R_BKT           reduce using rule 62 (lambda -> L_PAR R_PAR COLON type ARROW L_BRC block R_BRC .)


state 152

    (64) lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block . R_BRC

    R_BRC           shift and go to state 154


state 153

    (66) lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block . R_BRC

    R_BRC           shift and go to state 155


state 154

    (64) lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .

    SEMI            reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    L_BKT           reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    PLUS            reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    MINUS           reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    MULTIPLY        reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    DIVIDE          reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    MODULO          reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    EQ              reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    NEQ             reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    LT              reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    GT              reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    LEQ             reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    GEQ             reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    OR              reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    AND             reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    L_PAR           reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    R_PAR           reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    COMMA           reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)
    R_BKT           reduce using rule 64 (lambda -> L_PAR IDEN R_PAR COLON type ARROW L_BRC block R_BRC .)


state 155

    (66) lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .

    SEMI            reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    L_BKT           reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    PLUS            reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    MINUS           reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    MULTIPLY        reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    DIVIDE          reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    MODULO          reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    EQ              reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    NEQ             reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    LT              reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    GT              reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    LEQ             reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    GEQ             reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    OR              reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    AND             reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    L_PAR           reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    R_PAR           reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    COMMA           reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)
    R_BKT           reduce using rule 66 (lambda -> L_PAR param_list R_PAR COLON type ARROW L_BRC block R_BRC .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for R_PAR in state 49 resolved as shift
WARNING: shift/reduce conflict for R_PAR in state 49 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 122 resolved as shift
WARNING: shift/reduce conflict for ARROW in state 132 resolved as shift
