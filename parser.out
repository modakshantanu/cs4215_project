Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    MULTI_COMMENT
    SINGLE_COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     type -> NUMBER
Rule 3     type -> BOOL
Rule 4     type -> STRING
Rule 5     type -> ANY
Rule 6     block -> statement
Rule 7     block -> statement block
Rule 8     statement -> expression SEMI
Rule 9     statement -> IDEN ASSIGN expression SEMI
Rule 10    statement -> LET IDEN SEMI
Rule 11    statement -> LET IDEN COLON type SEMI
Rule 12    statement -> LET IDEN ASSIGN expression SEMI
Rule 13    statement -> LET IDEN COLON type ASSIGN expression SEMI
Rule 14    statement -> RETURN expression SEMI
Rule 15    statement -> IF L_PAR expression R_PAR statement ELSE statement
Rule 16    statement -> IF L_PAR expression R_PAR statement
Rule 17    statement -> WHILE L_PAR expression R_PAR statement
Rule 18    statement -> L_BRC block R_BRC
Rule 19    statement -> BREAK SEMI
Rule 20    statement -> CONTINUE SEMI
Rule 21    expression -> binary_operation
Rule 22    expression -> unary_operation
Rule 23    expression -> L_PAR expression R_PAR
Rule 24    expression -> NUM_LIT
Rule 25    expression -> BOOL_LIT
Rule 26    expression -> STR_LIT
Rule 27    expression -> function_call
Rule 28    expression -> lambda
Rule 29    expression -> IDEN
Rule 30    binary_operation -> expression PLUS expression
Rule 31    binary_operation -> expression MINUS expression
Rule 32    binary_operation -> expression MULTIPLY expression
Rule 33    binary_operation -> expression DIVIDE expression
Rule 34    binary_operation -> expression MODULO expression
Rule 35    binary_operation -> expression EQ expression
Rule 36    binary_operation -> expression NEQ expression
Rule 37    binary_operation -> expression LT expression
Rule 38    binary_operation -> expression GT expression
Rule 39    binary_operation -> expression LEQ expression
Rule 40    binary_operation -> expression GEQ expression
Rule 41    binary_operation -> expression OR expression
Rule 42    binary_operation -> expression AND expression
Rule 43    unary_operation -> PLUS expression
Rule 44    unary_operation -> MINUS expression
Rule 45    unary_operation -> NOT expression
Rule 46    arg_list -> expression
Rule 47    arg_list -> expression COMMA arg_list
Rule 48    param_list -> IDEN COMMA param_list
Rule 49    param_list -> IDEN
Rule 50    function_call -> expression L_PAR R_PAR
Rule 51    function_call -> expression L_PAR arg_list R_PAR
Rule 52    lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC
Rule 53    lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC
Rule 54    lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

Terminals, with rules where they appear

AND                  : 42
ANY                  : 5
ARROW                : 52 53 54
ASSIGN               : 9 12 13
BOOL                 : 3
BOOL_LIT             : 25
BREAK                : 19
COLON                : 11 13
COMMA                : 47 48
CONTINUE             : 20
DIVIDE               : 33
ELSE                 : 15
EQ                   : 35
GEQ                  : 40
GT                   : 38
IDEN                 : 9 10 11 12 13 29 48 49 54
IF                   : 15 16
LEQ                  : 39
LET                  : 10 11 12 13
LT                   : 37
L_BRC                : 18 52 53 54
L_PAR                : 15 16 17 23 50 51 52 53 54
MINUS                : 31 44
MODULO               : 34
MULTIPLY             : 32
MULTI_COMMENT        : 
NEQ                  : 36
NOT                  : 45
NUMBER               : 2
NUM_LIT              : 24
OR                   : 41
PLUS                 : 30 43
RETURN               : 14
R_BRC                : 18 52 53 54
R_PAR                : 15 16 17 23 50 51 52 53 54
SEMI                 : 8 9 10 11 12 13 14 19 20
SINGLE_COMMENT       : 
STRING               : 4
STR_LIT              : 26
WHILE                : 17
error                : 

Nonterminals, with rules where they appear

arg_list             : 47 51
binary_operation     : 21
block                : 1 7 18 52 53 54
expression           : 8 9 12 13 14 15 16 17 23 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 44 45 46 47 50 51
function_call        : 27
lambda               : 28
param_list           : 48 53
program              : 0
statement            : 6 7 15 15 16 17
type                 : 11 13
unary_operation      : 22

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (6) block -> . statement
    (7) block -> . statement block
    (8) statement -> . expression SEMI
    (9) statement -> . IDEN ASSIGN expression SEMI
    (10) statement -> . LET IDEN SEMI
    (11) statement -> . LET IDEN COLON type SEMI
    (12) statement -> . LET IDEN ASSIGN expression SEMI
    (13) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (14) statement -> . RETURN expression SEMI
    (15) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (16) statement -> . IF L_PAR expression R_PAR statement
    (17) statement -> . WHILE L_PAR expression R_PAR statement
    (18) statement -> . L_BRC block R_BRC
    (19) statement -> . BREAK SEMI
    (20) statement -> . CONTINUE SEMI
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    program                        shift and go to state 1
    block                          shift and go to state 2
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (6) block -> statement .
    (7) block -> statement . block
    (6) block -> . statement
    (7) block -> . statement block
    (8) statement -> . expression SEMI
    (9) statement -> . IDEN ASSIGN expression SEMI
    (10) statement -> . LET IDEN SEMI
    (11) statement -> . LET IDEN COLON type SEMI
    (12) statement -> . LET IDEN ASSIGN expression SEMI
    (13) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (14) statement -> . RETURN expression SEMI
    (15) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (16) statement -> . IF L_PAR expression R_PAR statement
    (17) statement -> . WHILE L_PAR expression R_PAR statement
    (18) statement -> . L_BRC block R_BRC
    (19) statement -> . BREAK SEMI
    (20) statement -> . CONTINUE SEMI
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    $end            reduce using rule 6 (block -> statement .)
    R_BRC           reduce using rule 6 (block -> statement .)
    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    statement                      shift and go to state 3
    block                          shift and go to state 24
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 4

    (8) statement -> expression . SEMI
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 5

    (9) statement -> IDEN . ASSIGN expression SEMI
    (29) expression -> IDEN .

    ASSIGN          shift and go to state 40
    SEMI            reduce using rule 29 (expression -> IDEN .)
    PLUS            reduce using rule 29 (expression -> IDEN .)
    MINUS           reduce using rule 29 (expression -> IDEN .)
    MULTIPLY        reduce using rule 29 (expression -> IDEN .)
    DIVIDE          reduce using rule 29 (expression -> IDEN .)
    MODULO          reduce using rule 29 (expression -> IDEN .)
    EQ              reduce using rule 29 (expression -> IDEN .)
    NEQ             reduce using rule 29 (expression -> IDEN .)
    LT              reduce using rule 29 (expression -> IDEN .)
    GT              reduce using rule 29 (expression -> IDEN .)
    LEQ             reduce using rule 29 (expression -> IDEN .)
    GEQ             reduce using rule 29 (expression -> IDEN .)
    OR              reduce using rule 29 (expression -> IDEN .)
    AND             reduce using rule 29 (expression -> IDEN .)
    L_PAR           reduce using rule 29 (expression -> IDEN .)


state 6

    (10) statement -> LET . IDEN SEMI
    (11) statement -> LET . IDEN COLON type SEMI
    (12) statement -> LET . IDEN ASSIGN expression SEMI
    (13) statement -> LET . IDEN COLON type ASSIGN expression SEMI

    IDEN            shift and go to state 41


state 7

    (14) statement -> RETURN . expression SEMI
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 42
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 8

    (15) statement -> IF . L_PAR expression R_PAR statement ELSE statement
    (16) statement -> IF . L_PAR expression R_PAR statement

    L_PAR           shift and go to state 44


state 9

    (23) expression -> L_PAR . expression R_PAR
    (52) lambda -> L_PAR . R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> L_PAR . param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> L_PAR . IDEN R_PAR ARROW L_BRC block R_BRC
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (48) param_list -> . IDEN COMMA param_list
    (49) param_list -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    R_PAR           shift and go to state 46
    IDEN            shift and go to state 48
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 45
    param_list                     shift and go to state 47
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 10

    (17) statement -> WHILE . L_PAR expression R_PAR statement

    L_PAR           shift and go to state 49


state 11

    (18) statement -> L_BRC . block R_BRC
    (6) block -> . statement
    (7) block -> . statement block
    (8) statement -> . expression SEMI
    (9) statement -> . IDEN ASSIGN expression SEMI
    (10) statement -> . LET IDEN SEMI
    (11) statement -> . LET IDEN COLON type SEMI
    (12) statement -> . LET IDEN ASSIGN expression SEMI
    (13) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (14) statement -> . RETURN expression SEMI
    (15) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (16) statement -> . IF L_PAR expression R_PAR statement
    (17) statement -> . WHILE L_PAR expression R_PAR statement
    (18) statement -> . L_BRC block R_BRC
    (19) statement -> . BREAK SEMI
    (20) statement -> . CONTINUE SEMI
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    block                          shift and go to state 50
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 12

    (19) statement -> BREAK . SEMI

    SEMI            shift and go to state 51


state 13

    (20) statement -> CONTINUE . SEMI

    SEMI            shift and go to state 52


state 14

    (21) expression -> binary_operation .

    SEMI            reduce using rule 21 (expression -> binary_operation .)
    PLUS            reduce using rule 21 (expression -> binary_operation .)
    MINUS           reduce using rule 21 (expression -> binary_operation .)
    MULTIPLY        reduce using rule 21 (expression -> binary_operation .)
    DIVIDE          reduce using rule 21 (expression -> binary_operation .)
    MODULO          reduce using rule 21 (expression -> binary_operation .)
    EQ              reduce using rule 21 (expression -> binary_operation .)
    NEQ             reduce using rule 21 (expression -> binary_operation .)
    LT              reduce using rule 21 (expression -> binary_operation .)
    GT              reduce using rule 21 (expression -> binary_operation .)
    LEQ             reduce using rule 21 (expression -> binary_operation .)
    GEQ             reduce using rule 21 (expression -> binary_operation .)
    OR              reduce using rule 21 (expression -> binary_operation .)
    AND             reduce using rule 21 (expression -> binary_operation .)
    L_PAR           reduce using rule 21 (expression -> binary_operation .)
    R_PAR           reduce using rule 21 (expression -> binary_operation .)
    COMMA           reduce using rule 21 (expression -> binary_operation .)


state 15

    (22) expression -> unary_operation .

    SEMI            reduce using rule 22 (expression -> unary_operation .)
    PLUS            reduce using rule 22 (expression -> unary_operation .)
    MINUS           reduce using rule 22 (expression -> unary_operation .)
    MULTIPLY        reduce using rule 22 (expression -> unary_operation .)
    DIVIDE          reduce using rule 22 (expression -> unary_operation .)
    MODULO          reduce using rule 22 (expression -> unary_operation .)
    EQ              reduce using rule 22 (expression -> unary_operation .)
    NEQ             reduce using rule 22 (expression -> unary_operation .)
    LT              reduce using rule 22 (expression -> unary_operation .)
    GT              reduce using rule 22 (expression -> unary_operation .)
    LEQ             reduce using rule 22 (expression -> unary_operation .)
    GEQ             reduce using rule 22 (expression -> unary_operation .)
    OR              reduce using rule 22 (expression -> unary_operation .)
    AND             reduce using rule 22 (expression -> unary_operation .)
    L_PAR           reduce using rule 22 (expression -> unary_operation .)
    R_PAR           reduce using rule 22 (expression -> unary_operation .)
    COMMA           reduce using rule 22 (expression -> unary_operation .)


state 16

    (24) expression -> NUM_LIT .

    SEMI            reduce using rule 24 (expression -> NUM_LIT .)
    PLUS            reduce using rule 24 (expression -> NUM_LIT .)
    MINUS           reduce using rule 24 (expression -> NUM_LIT .)
    MULTIPLY        reduce using rule 24 (expression -> NUM_LIT .)
    DIVIDE          reduce using rule 24 (expression -> NUM_LIT .)
    MODULO          reduce using rule 24 (expression -> NUM_LIT .)
    EQ              reduce using rule 24 (expression -> NUM_LIT .)
    NEQ             reduce using rule 24 (expression -> NUM_LIT .)
    LT              reduce using rule 24 (expression -> NUM_LIT .)
    GT              reduce using rule 24 (expression -> NUM_LIT .)
    LEQ             reduce using rule 24 (expression -> NUM_LIT .)
    GEQ             reduce using rule 24 (expression -> NUM_LIT .)
    OR              reduce using rule 24 (expression -> NUM_LIT .)
    AND             reduce using rule 24 (expression -> NUM_LIT .)
    L_PAR           reduce using rule 24 (expression -> NUM_LIT .)
    R_PAR           reduce using rule 24 (expression -> NUM_LIT .)
    COMMA           reduce using rule 24 (expression -> NUM_LIT .)


state 17

    (25) expression -> BOOL_LIT .

    SEMI            reduce using rule 25 (expression -> BOOL_LIT .)
    PLUS            reduce using rule 25 (expression -> BOOL_LIT .)
    MINUS           reduce using rule 25 (expression -> BOOL_LIT .)
    MULTIPLY        reduce using rule 25 (expression -> BOOL_LIT .)
    DIVIDE          reduce using rule 25 (expression -> BOOL_LIT .)
    MODULO          reduce using rule 25 (expression -> BOOL_LIT .)
    EQ              reduce using rule 25 (expression -> BOOL_LIT .)
    NEQ             reduce using rule 25 (expression -> BOOL_LIT .)
    LT              reduce using rule 25 (expression -> BOOL_LIT .)
    GT              reduce using rule 25 (expression -> BOOL_LIT .)
    LEQ             reduce using rule 25 (expression -> BOOL_LIT .)
    GEQ             reduce using rule 25 (expression -> BOOL_LIT .)
    OR              reduce using rule 25 (expression -> BOOL_LIT .)
    AND             reduce using rule 25 (expression -> BOOL_LIT .)
    L_PAR           reduce using rule 25 (expression -> BOOL_LIT .)
    R_PAR           reduce using rule 25 (expression -> BOOL_LIT .)
    COMMA           reduce using rule 25 (expression -> BOOL_LIT .)


state 18

    (26) expression -> STR_LIT .

    SEMI            reduce using rule 26 (expression -> STR_LIT .)
    PLUS            reduce using rule 26 (expression -> STR_LIT .)
    MINUS           reduce using rule 26 (expression -> STR_LIT .)
    MULTIPLY        reduce using rule 26 (expression -> STR_LIT .)
    DIVIDE          reduce using rule 26 (expression -> STR_LIT .)
    MODULO          reduce using rule 26 (expression -> STR_LIT .)
    EQ              reduce using rule 26 (expression -> STR_LIT .)
    NEQ             reduce using rule 26 (expression -> STR_LIT .)
    LT              reduce using rule 26 (expression -> STR_LIT .)
    GT              reduce using rule 26 (expression -> STR_LIT .)
    LEQ             reduce using rule 26 (expression -> STR_LIT .)
    GEQ             reduce using rule 26 (expression -> STR_LIT .)
    OR              reduce using rule 26 (expression -> STR_LIT .)
    AND             reduce using rule 26 (expression -> STR_LIT .)
    L_PAR           reduce using rule 26 (expression -> STR_LIT .)
    R_PAR           reduce using rule 26 (expression -> STR_LIT .)
    COMMA           reduce using rule 26 (expression -> STR_LIT .)


state 19

    (27) expression -> function_call .

    SEMI            reduce using rule 27 (expression -> function_call .)
    PLUS            reduce using rule 27 (expression -> function_call .)
    MINUS           reduce using rule 27 (expression -> function_call .)
    MULTIPLY        reduce using rule 27 (expression -> function_call .)
    DIVIDE          reduce using rule 27 (expression -> function_call .)
    MODULO          reduce using rule 27 (expression -> function_call .)
    EQ              reduce using rule 27 (expression -> function_call .)
    NEQ             reduce using rule 27 (expression -> function_call .)
    LT              reduce using rule 27 (expression -> function_call .)
    GT              reduce using rule 27 (expression -> function_call .)
    LEQ             reduce using rule 27 (expression -> function_call .)
    GEQ             reduce using rule 27 (expression -> function_call .)
    OR              reduce using rule 27 (expression -> function_call .)
    AND             reduce using rule 27 (expression -> function_call .)
    L_PAR           reduce using rule 27 (expression -> function_call .)
    R_PAR           reduce using rule 27 (expression -> function_call .)
    COMMA           reduce using rule 27 (expression -> function_call .)


state 20

    (28) expression -> lambda .

    SEMI            reduce using rule 28 (expression -> lambda .)
    PLUS            reduce using rule 28 (expression -> lambda .)
    MINUS           reduce using rule 28 (expression -> lambda .)
    MULTIPLY        reduce using rule 28 (expression -> lambda .)
    DIVIDE          reduce using rule 28 (expression -> lambda .)
    MODULO          reduce using rule 28 (expression -> lambda .)
    EQ              reduce using rule 28 (expression -> lambda .)
    NEQ             reduce using rule 28 (expression -> lambda .)
    LT              reduce using rule 28 (expression -> lambda .)
    GT              reduce using rule 28 (expression -> lambda .)
    LEQ             reduce using rule 28 (expression -> lambda .)
    GEQ             reduce using rule 28 (expression -> lambda .)
    OR              reduce using rule 28 (expression -> lambda .)
    AND             reduce using rule 28 (expression -> lambda .)
    L_PAR           reduce using rule 28 (expression -> lambda .)
    R_PAR           reduce using rule 28 (expression -> lambda .)
    COMMA           reduce using rule 28 (expression -> lambda .)


state 21

    (43) unary_operation -> PLUS . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 53
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 22

    (44) unary_operation -> MINUS . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 54
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 23

    (45) unary_operation -> NOT . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 55
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 24

    (7) block -> statement block .

    $end            reduce using rule 7 (block -> statement block .)
    R_BRC           reduce using rule 7 (block -> statement block .)


state 25

    (8) statement -> expression SEMI .

    IDEN            reduce using rule 8 (statement -> expression SEMI .)
    LET             reduce using rule 8 (statement -> expression SEMI .)
    RETURN          reduce using rule 8 (statement -> expression SEMI .)
    IF              reduce using rule 8 (statement -> expression SEMI .)
    WHILE           reduce using rule 8 (statement -> expression SEMI .)
    L_BRC           reduce using rule 8 (statement -> expression SEMI .)
    BREAK           reduce using rule 8 (statement -> expression SEMI .)
    CONTINUE        reduce using rule 8 (statement -> expression SEMI .)
    L_PAR           reduce using rule 8 (statement -> expression SEMI .)
    NUM_LIT         reduce using rule 8 (statement -> expression SEMI .)
    BOOL_LIT        reduce using rule 8 (statement -> expression SEMI .)
    STR_LIT         reduce using rule 8 (statement -> expression SEMI .)
    PLUS            reduce using rule 8 (statement -> expression SEMI .)
    MINUS           reduce using rule 8 (statement -> expression SEMI .)
    NOT             reduce using rule 8 (statement -> expression SEMI .)
    $end            reduce using rule 8 (statement -> expression SEMI .)
    R_BRC           reduce using rule 8 (statement -> expression SEMI .)
    ELSE            reduce using rule 8 (statement -> expression SEMI .)


state 26

    (30) binary_operation -> expression PLUS . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 56
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 27

    (31) binary_operation -> expression MINUS . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 57
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 28

    (32) binary_operation -> expression MULTIPLY . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 58
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 29

    (33) binary_operation -> expression DIVIDE . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 59
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 30

    (34) binary_operation -> expression MODULO . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 60
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 31

    (35) binary_operation -> expression EQ . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 61
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 32

    (36) binary_operation -> expression NEQ . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 62
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 33

    (37) binary_operation -> expression LT . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 63
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 34

    (38) binary_operation -> expression GT . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 64
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 35

    (39) binary_operation -> expression LEQ . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 65
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 36

    (40) binary_operation -> expression GEQ . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 66
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 37

    (41) binary_operation -> expression OR . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 67
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 38

    (42) binary_operation -> expression AND . expression
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 68
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 39

    (50) function_call -> expression L_PAR . R_PAR
    (51) function_call -> expression L_PAR . arg_list R_PAR
    (46) arg_list -> . expression
    (47) arg_list -> . expression COMMA arg_list
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    R_PAR           shift and go to state 70
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 69
    arg_list                       shift and go to state 71
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 40

    (9) statement -> IDEN ASSIGN . expression SEMI
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 72
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 41

    (10) statement -> LET IDEN . SEMI
    (11) statement -> LET IDEN . COLON type SEMI
    (12) statement -> LET IDEN . ASSIGN expression SEMI
    (13) statement -> LET IDEN . COLON type ASSIGN expression SEMI

    SEMI            shift and go to state 73
    COLON           shift and go to state 74
    ASSIGN          shift and go to state 75


state 42

    (14) statement -> RETURN expression . SEMI
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 76
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 43

    (29) expression -> IDEN .

    SEMI            reduce using rule 29 (expression -> IDEN .)
    PLUS            reduce using rule 29 (expression -> IDEN .)
    MINUS           reduce using rule 29 (expression -> IDEN .)
    MULTIPLY        reduce using rule 29 (expression -> IDEN .)
    DIVIDE          reduce using rule 29 (expression -> IDEN .)
    MODULO          reduce using rule 29 (expression -> IDEN .)
    EQ              reduce using rule 29 (expression -> IDEN .)
    NEQ             reduce using rule 29 (expression -> IDEN .)
    LT              reduce using rule 29 (expression -> IDEN .)
    GT              reduce using rule 29 (expression -> IDEN .)
    LEQ             reduce using rule 29 (expression -> IDEN .)
    GEQ             reduce using rule 29 (expression -> IDEN .)
    OR              reduce using rule 29 (expression -> IDEN .)
    AND             reduce using rule 29 (expression -> IDEN .)
    L_PAR           reduce using rule 29 (expression -> IDEN .)
    R_PAR           reduce using rule 29 (expression -> IDEN .)
    COMMA           reduce using rule 29 (expression -> IDEN .)


state 44

    (15) statement -> IF L_PAR . expression R_PAR statement ELSE statement
    (16) statement -> IF L_PAR . expression R_PAR statement
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 77
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 45

    (23) expression -> L_PAR expression . R_PAR
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    R_PAR           shift and go to state 78
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 46

    (52) lambda -> L_PAR R_PAR . ARROW L_BRC block R_BRC

    ARROW           shift and go to state 79


state 47

    (53) lambda -> L_PAR param_list . R_PAR ARROW L_BRC block R_BRC

    R_PAR           shift and go to state 80


state 48

    (54) lambda -> L_PAR IDEN . R_PAR ARROW L_BRC block R_BRC
    (29) expression -> IDEN .
    (48) param_list -> IDEN . COMMA param_list
    (49) param_list -> IDEN .

  ! shift/reduce conflict for R_PAR resolved as shift
  ! shift/reduce conflict for R_PAR resolved as shift
    R_PAR           shift and go to state 81
    PLUS            reduce using rule 29 (expression -> IDEN .)
    MINUS           reduce using rule 29 (expression -> IDEN .)
    MULTIPLY        reduce using rule 29 (expression -> IDEN .)
    DIVIDE          reduce using rule 29 (expression -> IDEN .)
    MODULO          reduce using rule 29 (expression -> IDEN .)
    EQ              reduce using rule 29 (expression -> IDEN .)
    NEQ             reduce using rule 29 (expression -> IDEN .)
    LT              reduce using rule 29 (expression -> IDEN .)
    GT              reduce using rule 29 (expression -> IDEN .)
    LEQ             reduce using rule 29 (expression -> IDEN .)
    GEQ             reduce using rule 29 (expression -> IDEN .)
    OR              reduce using rule 29 (expression -> IDEN .)
    AND             reduce using rule 29 (expression -> IDEN .)
    L_PAR           reduce using rule 29 (expression -> IDEN .)
    COMMA           shift and go to state 82

  ! R_PAR           [ reduce using rule 29 (expression -> IDEN .) ]
  ! R_PAR           [ reduce using rule 49 (param_list -> IDEN .) ]


state 49

    (17) statement -> WHILE L_PAR . expression R_PAR statement
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 83
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 50

    (18) statement -> L_BRC block . R_BRC

    R_BRC           shift and go to state 84


state 51

    (19) statement -> BREAK SEMI .

    IDEN            reduce using rule 19 (statement -> BREAK SEMI .)
    LET             reduce using rule 19 (statement -> BREAK SEMI .)
    RETURN          reduce using rule 19 (statement -> BREAK SEMI .)
    IF              reduce using rule 19 (statement -> BREAK SEMI .)
    WHILE           reduce using rule 19 (statement -> BREAK SEMI .)
    L_BRC           reduce using rule 19 (statement -> BREAK SEMI .)
    BREAK           reduce using rule 19 (statement -> BREAK SEMI .)
    CONTINUE        reduce using rule 19 (statement -> BREAK SEMI .)
    L_PAR           reduce using rule 19 (statement -> BREAK SEMI .)
    NUM_LIT         reduce using rule 19 (statement -> BREAK SEMI .)
    BOOL_LIT        reduce using rule 19 (statement -> BREAK SEMI .)
    STR_LIT         reduce using rule 19 (statement -> BREAK SEMI .)
    PLUS            reduce using rule 19 (statement -> BREAK SEMI .)
    MINUS           reduce using rule 19 (statement -> BREAK SEMI .)
    NOT             reduce using rule 19 (statement -> BREAK SEMI .)
    $end            reduce using rule 19 (statement -> BREAK SEMI .)
    R_BRC           reduce using rule 19 (statement -> BREAK SEMI .)
    ELSE            reduce using rule 19 (statement -> BREAK SEMI .)


state 52

    (20) statement -> CONTINUE SEMI .

    IDEN            reduce using rule 20 (statement -> CONTINUE SEMI .)
    LET             reduce using rule 20 (statement -> CONTINUE SEMI .)
    RETURN          reduce using rule 20 (statement -> CONTINUE SEMI .)
    IF              reduce using rule 20 (statement -> CONTINUE SEMI .)
    WHILE           reduce using rule 20 (statement -> CONTINUE SEMI .)
    L_BRC           reduce using rule 20 (statement -> CONTINUE SEMI .)
    BREAK           reduce using rule 20 (statement -> CONTINUE SEMI .)
    CONTINUE        reduce using rule 20 (statement -> CONTINUE SEMI .)
    L_PAR           reduce using rule 20 (statement -> CONTINUE SEMI .)
    NUM_LIT         reduce using rule 20 (statement -> CONTINUE SEMI .)
    BOOL_LIT        reduce using rule 20 (statement -> CONTINUE SEMI .)
    STR_LIT         reduce using rule 20 (statement -> CONTINUE SEMI .)
    PLUS            reduce using rule 20 (statement -> CONTINUE SEMI .)
    MINUS           reduce using rule 20 (statement -> CONTINUE SEMI .)
    NOT             reduce using rule 20 (statement -> CONTINUE SEMI .)
    $end            reduce using rule 20 (statement -> CONTINUE SEMI .)
    R_BRC           reduce using rule 20 (statement -> CONTINUE SEMI .)
    ELSE            reduce using rule 20 (statement -> CONTINUE SEMI .)


state 53

    (43) unary_operation -> PLUS expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 43 (unary_operation -> PLUS expression .)
    PLUS            reduce using rule 43 (unary_operation -> PLUS expression .)
    MINUS           reduce using rule 43 (unary_operation -> PLUS expression .)
    MULTIPLY        reduce using rule 43 (unary_operation -> PLUS expression .)
    DIVIDE          reduce using rule 43 (unary_operation -> PLUS expression .)
    MODULO          reduce using rule 43 (unary_operation -> PLUS expression .)
    EQ              reduce using rule 43 (unary_operation -> PLUS expression .)
    NEQ             reduce using rule 43 (unary_operation -> PLUS expression .)
    LT              reduce using rule 43 (unary_operation -> PLUS expression .)
    GT              reduce using rule 43 (unary_operation -> PLUS expression .)
    LEQ             reduce using rule 43 (unary_operation -> PLUS expression .)
    GEQ             reduce using rule 43 (unary_operation -> PLUS expression .)
    OR              reduce using rule 43 (unary_operation -> PLUS expression .)
    AND             reduce using rule 43 (unary_operation -> PLUS expression .)
    L_PAR           reduce using rule 43 (unary_operation -> PLUS expression .)
    R_PAR           reduce using rule 43 (unary_operation -> PLUS expression .)
    COMMA           reduce using rule 43 (unary_operation -> PLUS expression .)

  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MULTIPLY        [ shift and go to state 28 ]
  ! DIVIDE          [ shift and go to state 29 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 54

    (44) unary_operation -> MINUS expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 44 (unary_operation -> MINUS expression .)
    PLUS            reduce using rule 44 (unary_operation -> MINUS expression .)
    MINUS           reduce using rule 44 (unary_operation -> MINUS expression .)
    MULTIPLY        reduce using rule 44 (unary_operation -> MINUS expression .)
    DIVIDE          reduce using rule 44 (unary_operation -> MINUS expression .)
    MODULO          reduce using rule 44 (unary_operation -> MINUS expression .)
    EQ              reduce using rule 44 (unary_operation -> MINUS expression .)
    NEQ             reduce using rule 44 (unary_operation -> MINUS expression .)
    LT              reduce using rule 44 (unary_operation -> MINUS expression .)
    GT              reduce using rule 44 (unary_operation -> MINUS expression .)
    LEQ             reduce using rule 44 (unary_operation -> MINUS expression .)
    GEQ             reduce using rule 44 (unary_operation -> MINUS expression .)
    OR              reduce using rule 44 (unary_operation -> MINUS expression .)
    AND             reduce using rule 44 (unary_operation -> MINUS expression .)
    L_PAR           reduce using rule 44 (unary_operation -> MINUS expression .)
    R_PAR           reduce using rule 44 (unary_operation -> MINUS expression .)
    COMMA           reduce using rule 44 (unary_operation -> MINUS expression .)

  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MULTIPLY        [ shift and go to state 28 ]
  ! DIVIDE          [ shift and go to state 29 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 55

    (45) unary_operation -> NOT expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 45 (unary_operation -> NOT expression .)
    PLUS            reduce using rule 45 (unary_operation -> NOT expression .)
    MINUS           reduce using rule 45 (unary_operation -> NOT expression .)
    MULTIPLY        reduce using rule 45 (unary_operation -> NOT expression .)
    DIVIDE          reduce using rule 45 (unary_operation -> NOT expression .)
    MODULO          reduce using rule 45 (unary_operation -> NOT expression .)
    EQ              reduce using rule 45 (unary_operation -> NOT expression .)
    NEQ             reduce using rule 45 (unary_operation -> NOT expression .)
    LT              reduce using rule 45 (unary_operation -> NOT expression .)
    GT              reduce using rule 45 (unary_operation -> NOT expression .)
    LEQ             reduce using rule 45 (unary_operation -> NOT expression .)
    GEQ             reduce using rule 45 (unary_operation -> NOT expression .)
    OR              reduce using rule 45 (unary_operation -> NOT expression .)
    AND             reduce using rule 45 (unary_operation -> NOT expression .)
    L_PAR           reduce using rule 45 (unary_operation -> NOT expression .)
    R_PAR           reduce using rule 45 (unary_operation -> NOT expression .)
    COMMA           reduce using rule 45 (unary_operation -> NOT expression .)

  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MULTIPLY        [ shift and go to state 28 ]
  ! DIVIDE          [ shift and go to state 29 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 56

    (30) binary_operation -> expression PLUS expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 30 (binary_operation -> expression PLUS expression .)
    PLUS            reduce using rule 30 (binary_operation -> expression PLUS expression .)
    MINUS           reduce using rule 30 (binary_operation -> expression PLUS expression .)
    MODULO          reduce using rule 30 (binary_operation -> expression PLUS expression .)
    EQ              reduce using rule 30 (binary_operation -> expression PLUS expression .)
    NEQ             reduce using rule 30 (binary_operation -> expression PLUS expression .)
    LT              reduce using rule 30 (binary_operation -> expression PLUS expression .)
    GT              reduce using rule 30 (binary_operation -> expression PLUS expression .)
    LEQ             reduce using rule 30 (binary_operation -> expression PLUS expression .)
    GEQ             reduce using rule 30 (binary_operation -> expression PLUS expression .)
    OR              reduce using rule 30 (binary_operation -> expression PLUS expression .)
    AND             reduce using rule 30 (binary_operation -> expression PLUS expression .)
    L_PAR           reduce using rule 30 (binary_operation -> expression PLUS expression .)
    R_PAR           reduce using rule 30 (binary_operation -> expression PLUS expression .)
    COMMA           reduce using rule 30 (binary_operation -> expression PLUS expression .)
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29

  ! MULTIPLY        [ reduce using rule 30 (binary_operation -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 30 (binary_operation -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 57

    (31) binary_operation -> expression MINUS expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 31 (binary_operation -> expression MINUS expression .)
    PLUS            reduce using rule 31 (binary_operation -> expression MINUS expression .)
    MINUS           reduce using rule 31 (binary_operation -> expression MINUS expression .)
    MODULO          reduce using rule 31 (binary_operation -> expression MINUS expression .)
    EQ              reduce using rule 31 (binary_operation -> expression MINUS expression .)
    NEQ             reduce using rule 31 (binary_operation -> expression MINUS expression .)
    LT              reduce using rule 31 (binary_operation -> expression MINUS expression .)
    GT              reduce using rule 31 (binary_operation -> expression MINUS expression .)
    LEQ             reduce using rule 31 (binary_operation -> expression MINUS expression .)
    GEQ             reduce using rule 31 (binary_operation -> expression MINUS expression .)
    OR              reduce using rule 31 (binary_operation -> expression MINUS expression .)
    AND             reduce using rule 31 (binary_operation -> expression MINUS expression .)
    L_PAR           reduce using rule 31 (binary_operation -> expression MINUS expression .)
    R_PAR           reduce using rule 31 (binary_operation -> expression MINUS expression .)
    COMMA           reduce using rule 31 (binary_operation -> expression MINUS expression .)
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29

  ! MULTIPLY        [ reduce using rule 31 (binary_operation -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 31 (binary_operation -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 58

    (32) binary_operation -> expression MULTIPLY expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    PLUS            reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    MINUS           reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    MULTIPLY        reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    DIVIDE          reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    MODULO          reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    EQ              reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    NEQ             reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    LT              reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    GT              reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    LEQ             reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    GEQ             reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    OR              reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    AND             reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    L_PAR           reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    R_PAR           reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)
    COMMA           reduce using rule 32 (binary_operation -> expression MULTIPLY expression .)

  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MULTIPLY        [ shift and go to state 28 ]
  ! DIVIDE          [ shift and go to state 29 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 59

    (33) binary_operation -> expression DIVIDE expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    PLUS            reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    MINUS           reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    MULTIPLY        reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    MODULO          reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    EQ              reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    NEQ             reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    LT              reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    GT              reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    LEQ             reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    GEQ             reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    OR              reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    AND             reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    L_PAR           reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    R_PAR           reduce using rule 33 (binary_operation -> expression DIVIDE expression .)
    COMMA           reduce using rule 33 (binary_operation -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! MULTIPLY        [ shift and go to state 28 ]
  ! DIVIDE          [ shift and go to state 29 ]
  ! MODULO          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! NEQ             [ shift and go to state 32 ]
  ! LT              [ shift and go to state 33 ]
  ! GT              [ shift and go to state 34 ]
  ! LEQ             [ shift and go to state 35 ]
  ! GEQ             [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! AND             [ shift and go to state 38 ]
  ! L_PAR           [ shift and go to state 39 ]


state 60

    (34) binary_operation -> expression MODULO expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 34 (binary_operation -> expression MODULO expression .)
    R_PAR           reduce using rule 34 (binary_operation -> expression MODULO expression .)
    COMMA           reduce using rule 34 (binary_operation -> expression MODULO expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]
  ! MINUS           [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]
  ! MULTIPLY        [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]
  ! DIVIDE          [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]
  ! MODULO          [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]
  ! EQ              [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]
  ! NEQ             [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]
  ! LT              [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]
  ! GT              [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]
  ! LEQ             [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]
  ! GEQ             [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]
  ! OR              [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]
  ! AND             [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]
  ! L_PAR           [ reduce using rule 34 (binary_operation -> expression MODULO expression .) ]


state 61

    (35) binary_operation -> expression EQ expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 35 (binary_operation -> expression EQ expression .)
    R_PAR           reduce using rule 35 (binary_operation -> expression EQ expression .)
    COMMA           reduce using rule 35 (binary_operation -> expression EQ expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]
  ! MULTIPLY        [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]
  ! MODULO          [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]
  ! EQ              [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]
  ! NEQ             [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]
  ! LT              [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]
  ! GT              [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]
  ! LEQ             [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]
  ! GEQ             [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]
  ! OR              [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]
  ! AND             [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]
  ! L_PAR           [ reduce using rule 35 (binary_operation -> expression EQ expression .) ]


state 62

    (36) binary_operation -> expression NEQ expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 36 (binary_operation -> expression NEQ expression .)
    R_PAR           reduce using rule 36 (binary_operation -> expression NEQ expression .)
    COMMA           reduce using rule 36 (binary_operation -> expression NEQ expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]
  ! MINUS           [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]
  ! MULTIPLY        [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]
  ! DIVIDE          [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]
  ! MODULO          [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]
  ! EQ              [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]
  ! NEQ             [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]
  ! LT              [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]
  ! GT              [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]
  ! LEQ             [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]
  ! GEQ             [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]
  ! OR              [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]
  ! AND             [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]
  ! L_PAR           [ reduce using rule 36 (binary_operation -> expression NEQ expression .) ]


state 63

    (37) binary_operation -> expression LT expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 37 (binary_operation -> expression LT expression .)
    R_PAR           reduce using rule 37 (binary_operation -> expression LT expression .)
    COMMA           reduce using rule 37 (binary_operation -> expression LT expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 37 (binary_operation -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 37 (binary_operation -> expression LT expression .) ]
  ! MULTIPLY        [ reduce using rule 37 (binary_operation -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 37 (binary_operation -> expression LT expression .) ]
  ! MODULO          [ reduce using rule 37 (binary_operation -> expression LT expression .) ]
  ! EQ              [ reduce using rule 37 (binary_operation -> expression LT expression .) ]
  ! NEQ             [ reduce using rule 37 (binary_operation -> expression LT expression .) ]
  ! LT              [ reduce using rule 37 (binary_operation -> expression LT expression .) ]
  ! GT              [ reduce using rule 37 (binary_operation -> expression LT expression .) ]
  ! LEQ             [ reduce using rule 37 (binary_operation -> expression LT expression .) ]
  ! GEQ             [ reduce using rule 37 (binary_operation -> expression LT expression .) ]
  ! OR              [ reduce using rule 37 (binary_operation -> expression LT expression .) ]
  ! AND             [ reduce using rule 37 (binary_operation -> expression LT expression .) ]
  ! L_PAR           [ reduce using rule 37 (binary_operation -> expression LT expression .) ]


state 64

    (38) binary_operation -> expression GT expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 38 (binary_operation -> expression GT expression .)
    R_PAR           reduce using rule 38 (binary_operation -> expression GT expression .)
    COMMA           reduce using rule 38 (binary_operation -> expression GT expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 38 (binary_operation -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 38 (binary_operation -> expression GT expression .) ]
  ! MULTIPLY        [ reduce using rule 38 (binary_operation -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 38 (binary_operation -> expression GT expression .) ]
  ! MODULO          [ reduce using rule 38 (binary_operation -> expression GT expression .) ]
  ! EQ              [ reduce using rule 38 (binary_operation -> expression GT expression .) ]
  ! NEQ             [ reduce using rule 38 (binary_operation -> expression GT expression .) ]
  ! LT              [ reduce using rule 38 (binary_operation -> expression GT expression .) ]
  ! GT              [ reduce using rule 38 (binary_operation -> expression GT expression .) ]
  ! LEQ             [ reduce using rule 38 (binary_operation -> expression GT expression .) ]
  ! GEQ             [ reduce using rule 38 (binary_operation -> expression GT expression .) ]
  ! OR              [ reduce using rule 38 (binary_operation -> expression GT expression .) ]
  ! AND             [ reduce using rule 38 (binary_operation -> expression GT expression .) ]
  ! L_PAR           [ reduce using rule 38 (binary_operation -> expression GT expression .) ]


state 65

    (39) binary_operation -> expression LEQ expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 39 (binary_operation -> expression LEQ expression .)
    R_PAR           reduce using rule 39 (binary_operation -> expression LEQ expression .)
    COMMA           reduce using rule 39 (binary_operation -> expression LEQ expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]
  ! MINUS           [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]
  ! MULTIPLY        [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]
  ! DIVIDE          [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]
  ! MODULO          [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]
  ! EQ              [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]
  ! NEQ             [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]
  ! LT              [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]
  ! GT              [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]
  ! LEQ             [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]
  ! GEQ             [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]
  ! OR              [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]
  ! AND             [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]
  ! L_PAR           [ reduce using rule 39 (binary_operation -> expression LEQ expression .) ]


state 66

    (40) binary_operation -> expression GEQ expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 40 (binary_operation -> expression GEQ expression .)
    R_PAR           reduce using rule 40 (binary_operation -> expression GEQ expression .)
    COMMA           reduce using rule 40 (binary_operation -> expression GEQ expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]
  ! MINUS           [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]
  ! MULTIPLY        [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]
  ! DIVIDE          [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]
  ! MODULO          [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]
  ! EQ              [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]
  ! NEQ             [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]
  ! LT              [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]
  ! GT              [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]
  ! LEQ             [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]
  ! GEQ             [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]
  ! OR              [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]
  ! AND             [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]
  ! L_PAR           [ reduce using rule 40 (binary_operation -> expression GEQ expression .) ]


state 67

    (41) binary_operation -> expression OR expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 41 (binary_operation -> expression OR expression .)
    R_PAR           reduce using rule 41 (binary_operation -> expression OR expression .)
    COMMA           reduce using rule 41 (binary_operation -> expression OR expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 41 (binary_operation -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 41 (binary_operation -> expression OR expression .) ]
  ! MULTIPLY        [ reduce using rule 41 (binary_operation -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 41 (binary_operation -> expression OR expression .) ]
  ! MODULO          [ reduce using rule 41 (binary_operation -> expression OR expression .) ]
  ! EQ              [ reduce using rule 41 (binary_operation -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 41 (binary_operation -> expression OR expression .) ]
  ! LT              [ reduce using rule 41 (binary_operation -> expression OR expression .) ]
  ! GT              [ reduce using rule 41 (binary_operation -> expression OR expression .) ]
  ! LEQ             [ reduce using rule 41 (binary_operation -> expression OR expression .) ]
  ! GEQ             [ reduce using rule 41 (binary_operation -> expression OR expression .) ]
  ! OR              [ reduce using rule 41 (binary_operation -> expression OR expression .) ]
  ! AND             [ reduce using rule 41 (binary_operation -> expression OR expression .) ]
  ! L_PAR           [ reduce using rule 41 (binary_operation -> expression OR expression .) ]


state 68

    (42) binary_operation -> expression AND expression .
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for L_PAR resolved as shift
    SEMI            reduce using rule 42 (binary_operation -> expression AND expression .)
    R_PAR           reduce using rule 42 (binary_operation -> expression AND expression .)
    COMMA           reduce using rule 42 (binary_operation -> expression AND expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39

  ! PLUS            [ reduce using rule 42 (binary_operation -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 42 (binary_operation -> expression AND expression .) ]
  ! MULTIPLY        [ reduce using rule 42 (binary_operation -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 42 (binary_operation -> expression AND expression .) ]
  ! MODULO          [ reduce using rule 42 (binary_operation -> expression AND expression .) ]
  ! EQ              [ reduce using rule 42 (binary_operation -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 42 (binary_operation -> expression AND expression .) ]
  ! LT              [ reduce using rule 42 (binary_operation -> expression AND expression .) ]
  ! GT              [ reduce using rule 42 (binary_operation -> expression AND expression .) ]
  ! LEQ             [ reduce using rule 42 (binary_operation -> expression AND expression .) ]
  ! GEQ             [ reduce using rule 42 (binary_operation -> expression AND expression .) ]
  ! OR              [ reduce using rule 42 (binary_operation -> expression AND expression .) ]
  ! AND             [ reduce using rule 42 (binary_operation -> expression AND expression .) ]
  ! L_PAR           [ reduce using rule 42 (binary_operation -> expression AND expression .) ]


state 69

    (46) arg_list -> expression .
    (47) arg_list -> expression . COMMA arg_list
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    R_PAR           reduce using rule 46 (arg_list -> expression .)
    COMMA           shift and go to state 85
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 70

    (50) function_call -> expression L_PAR R_PAR .

    SEMI            reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    PLUS            reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    MINUS           reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    MULTIPLY        reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    DIVIDE          reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    MODULO          reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    EQ              reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    NEQ             reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    LT              reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    GT              reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    LEQ             reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    GEQ             reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    OR              reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    AND             reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    L_PAR           reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    R_PAR           reduce using rule 50 (function_call -> expression L_PAR R_PAR .)
    COMMA           reduce using rule 50 (function_call -> expression L_PAR R_PAR .)


state 71

    (51) function_call -> expression L_PAR arg_list . R_PAR

    R_PAR           shift and go to state 86


state 72

    (9) statement -> IDEN ASSIGN expression . SEMI
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 87
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 73

    (10) statement -> LET IDEN SEMI .

    IDEN            reduce using rule 10 (statement -> LET IDEN SEMI .)
    LET             reduce using rule 10 (statement -> LET IDEN SEMI .)
    RETURN          reduce using rule 10 (statement -> LET IDEN SEMI .)
    IF              reduce using rule 10 (statement -> LET IDEN SEMI .)
    WHILE           reduce using rule 10 (statement -> LET IDEN SEMI .)
    L_BRC           reduce using rule 10 (statement -> LET IDEN SEMI .)
    BREAK           reduce using rule 10 (statement -> LET IDEN SEMI .)
    CONTINUE        reduce using rule 10 (statement -> LET IDEN SEMI .)
    L_PAR           reduce using rule 10 (statement -> LET IDEN SEMI .)
    NUM_LIT         reduce using rule 10 (statement -> LET IDEN SEMI .)
    BOOL_LIT        reduce using rule 10 (statement -> LET IDEN SEMI .)
    STR_LIT         reduce using rule 10 (statement -> LET IDEN SEMI .)
    PLUS            reduce using rule 10 (statement -> LET IDEN SEMI .)
    MINUS           reduce using rule 10 (statement -> LET IDEN SEMI .)
    NOT             reduce using rule 10 (statement -> LET IDEN SEMI .)
    $end            reduce using rule 10 (statement -> LET IDEN SEMI .)
    R_BRC           reduce using rule 10 (statement -> LET IDEN SEMI .)
    ELSE            reduce using rule 10 (statement -> LET IDEN SEMI .)


state 74

    (11) statement -> LET IDEN COLON . type SEMI
    (13) statement -> LET IDEN COLON . type ASSIGN expression SEMI
    (2) type -> . NUMBER
    (3) type -> . BOOL
    (4) type -> . STRING
    (5) type -> . ANY

    NUMBER          shift and go to state 89
    BOOL            shift and go to state 90
    STRING          shift and go to state 91
    ANY             shift and go to state 92

    type                           shift and go to state 88

state 75

    (12) statement -> LET IDEN ASSIGN . expression SEMI
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 93
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 76

    (14) statement -> RETURN expression SEMI .

    IDEN            reduce using rule 14 (statement -> RETURN expression SEMI .)
    LET             reduce using rule 14 (statement -> RETURN expression SEMI .)
    RETURN          reduce using rule 14 (statement -> RETURN expression SEMI .)
    IF              reduce using rule 14 (statement -> RETURN expression SEMI .)
    WHILE           reduce using rule 14 (statement -> RETURN expression SEMI .)
    L_BRC           reduce using rule 14 (statement -> RETURN expression SEMI .)
    BREAK           reduce using rule 14 (statement -> RETURN expression SEMI .)
    CONTINUE        reduce using rule 14 (statement -> RETURN expression SEMI .)
    L_PAR           reduce using rule 14 (statement -> RETURN expression SEMI .)
    NUM_LIT         reduce using rule 14 (statement -> RETURN expression SEMI .)
    BOOL_LIT        reduce using rule 14 (statement -> RETURN expression SEMI .)
    STR_LIT         reduce using rule 14 (statement -> RETURN expression SEMI .)
    PLUS            reduce using rule 14 (statement -> RETURN expression SEMI .)
    MINUS           reduce using rule 14 (statement -> RETURN expression SEMI .)
    NOT             reduce using rule 14 (statement -> RETURN expression SEMI .)
    $end            reduce using rule 14 (statement -> RETURN expression SEMI .)
    R_BRC           reduce using rule 14 (statement -> RETURN expression SEMI .)
    ELSE            reduce using rule 14 (statement -> RETURN expression SEMI .)


state 77

    (15) statement -> IF L_PAR expression . R_PAR statement ELSE statement
    (16) statement -> IF L_PAR expression . R_PAR statement
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    R_PAR           shift and go to state 94
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 78

    (23) expression -> L_PAR expression R_PAR .

    SEMI            reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    PLUS            reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    MINUS           reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    MULTIPLY        reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    DIVIDE          reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    MODULO          reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    EQ              reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    NEQ             reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    LT              reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    GT              reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    LEQ             reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    GEQ             reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    OR              reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    AND             reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    L_PAR           reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    R_PAR           reduce using rule 23 (expression -> L_PAR expression R_PAR .)
    COMMA           reduce using rule 23 (expression -> L_PAR expression R_PAR .)


state 79

    (52) lambda -> L_PAR R_PAR ARROW . L_BRC block R_BRC

    L_BRC           shift and go to state 95


state 80

    (53) lambda -> L_PAR param_list R_PAR . ARROW L_BRC block R_BRC

    ARROW           shift and go to state 96


state 81

    (54) lambda -> L_PAR IDEN R_PAR . ARROW L_BRC block R_BRC

    ARROW           shift and go to state 97


state 82

    (48) param_list -> IDEN COMMA . param_list
    (48) param_list -> . IDEN COMMA param_list
    (49) param_list -> . IDEN

    IDEN            shift and go to state 98

    param_list                     shift and go to state 99

state 83

    (17) statement -> WHILE L_PAR expression . R_PAR statement
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    R_PAR           shift and go to state 100
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 84

    (18) statement -> L_BRC block R_BRC .

    IDEN            reduce using rule 18 (statement -> L_BRC block R_BRC .)
    LET             reduce using rule 18 (statement -> L_BRC block R_BRC .)
    RETURN          reduce using rule 18 (statement -> L_BRC block R_BRC .)
    IF              reduce using rule 18 (statement -> L_BRC block R_BRC .)
    WHILE           reduce using rule 18 (statement -> L_BRC block R_BRC .)
    L_BRC           reduce using rule 18 (statement -> L_BRC block R_BRC .)
    BREAK           reduce using rule 18 (statement -> L_BRC block R_BRC .)
    CONTINUE        reduce using rule 18 (statement -> L_BRC block R_BRC .)
    L_PAR           reduce using rule 18 (statement -> L_BRC block R_BRC .)
    NUM_LIT         reduce using rule 18 (statement -> L_BRC block R_BRC .)
    BOOL_LIT        reduce using rule 18 (statement -> L_BRC block R_BRC .)
    STR_LIT         reduce using rule 18 (statement -> L_BRC block R_BRC .)
    PLUS            reduce using rule 18 (statement -> L_BRC block R_BRC .)
    MINUS           reduce using rule 18 (statement -> L_BRC block R_BRC .)
    NOT             reduce using rule 18 (statement -> L_BRC block R_BRC .)
    $end            reduce using rule 18 (statement -> L_BRC block R_BRC .)
    R_BRC           reduce using rule 18 (statement -> L_BRC block R_BRC .)
    ELSE            reduce using rule 18 (statement -> L_BRC block R_BRC .)


state 85

    (47) arg_list -> expression COMMA . arg_list
    (46) arg_list -> . expression
    (47) arg_list -> . expression COMMA arg_list
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 69
    arg_list                       shift and go to state 101
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 86

    (51) function_call -> expression L_PAR arg_list R_PAR .

    SEMI            reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    PLUS            reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    MINUS           reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    MULTIPLY        reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    DIVIDE          reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    MODULO          reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    EQ              reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    NEQ             reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    LT              reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    GT              reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    LEQ             reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    GEQ             reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    OR              reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    AND             reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    L_PAR           reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    R_PAR           reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)
    COMMA           reduce using rule 51 (function_call -> expression L_PAR arg_list R_PAR .)


state 87

    (9) statement -> IDEN ASSIGN expression SEMI .

    IDEN            reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    LET             reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    RETURN          reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    IF              reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    WHILE           reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    L_BRC           reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    BREAK           reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    CONTINUE        reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    L_PAR           reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    NUM_LIT         reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    BOOL_LIT        reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    STR_LIT         reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    PLUS            reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    MINUS           reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    NOT             reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    $end            reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    R_BRC           reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)
    ELSE            reduce using rule 9 (statement -> IDEN ASSIGN expression SEMI .)


state 88

    (11) statement -> LET IDEN COLON type . SEMI
    (13) statement -> LET IDEN COLON type . ASSIGN expression SEMI

    SEMI            shift and go to state 102
    ASSIGN          shift and go to state 103


state 89

    (2) type -> NUMBER .

    SEMI            reduce using rule 2 (type -> NUMBER .)
    ASSIGN          reduce using rule 2 (type -> NUMBER .)


state 90

    (3) type -> BOOL .

    SEMI            reduce using rule 3 (type -> BOOL .)
    ASSIGN          reduce using rule 3 (type -> BOOL .)


state 91

    (4) type -> STRING .

    SEMI            reduce using rule 4 (type -> STRING .)
    ASSIGN          reduce using rule 4 (type -> STRING .)


state 92

    (5) type -> ANY .

    SEMI            reduce using rule 5 (type -> ANY .)
    ASSIGN          reduce using rule 5 (type -> ANY .)


state 93

    (12) statement -> LET IDEN ASSIGN expression . SEMI
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 104
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 94

    (15) statement -> IF L_PAR expression R_PAR . statement ELSE statement
    (16) statement -> IF L_PAR expression R_PAR . statement
    (8) statement -> . expression SEMI
    (9) statement -> . IDEN ASSIGN expression SEMI
    (10) statement -> . LET IDEN SEMI
    (11) statement -> . LET IDEN COLON type SEMI
    (12) statement -> . LET IDEN ASSIGN expression SEMI
    (13) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (14) statement -> . RETURN expression SEMI
    (15) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (16) statement -> . IF L_PAR expression R_PAR statement
    (17) statement -> . WHILE L_PAR expression R_PAR statement
    (18) statement -> . L_BRC block R_BRC
    (19) statement -> . BREAK SEMI
    (20) statement -> . CONTINUE SEMI
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 4
    statement                      shift and go to state 105
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 95

    (52) lambda -> L_PAR R_PAR ARROW L_BRC . block R_BRC
    (6) block -> . statement
    (7) block -> . statement block
    (8) statement -> . expression SEMI
    (9) statement -> . IDEN ASSIGN expression SEMI
    (10) statement -> . LET IDEN SEMI
    (11) statement -> . LET IDEN COLON type SEMI
    (12) statement -> . LET IDEN ASSIGN expression SEMI
    (13) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (14) statement -> . RETURN expression SEMI
    (15) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (16) statement -> . IF L_PAR expression R_PAR statement
    (17) statement -> . WHILE L_PAR expression R_PAR statement
    (18) statement -> . L_BRC block R_BRC
    (19) statement -> . BREAK SEMI
    (20) statement -> . CONTINUE SEMI
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    block                          shift and go to state 106
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 96

    (53) lambda -> L_PAR param_list R_PAR ARROW . L_BRC block R_BRC

    L_BRC           shift and go to state 107


state 97

    (54) lambda -> L_PAR IDEN R_PAR ARROW . L_BRC block R_BRC

    L_BRC           shift and go to state 108


state 98

    (48) param_list -> IDEN . COMMA param_list
    (49) param_list -> IDEN .

    COMMA           shift and go to state 82
    R_PAR           reduce using rule 49 (param_list -> IDEN .)


state 99

    (48) param_list -> IDEN COMMA param_list .

    R_PAR           reduce using rule 48 (param_list -> IDEN COMMA param_list .)


state 100

    (17) statement -> WHILE L_PAR expression R_PAR . statement
    (8) statement -> . expression SEMI
    (9) statement -> . IDEN ASSIGN expression SEMI
    (10) statement -> . LET IDEN SEMI
    (11) statement -> . LET IDEN COLON type SEMI
    (12) statement -> . LET IDEN ASSIGN expression SEMI
    (13) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (14) statement -> . RETURN expression SEMI
    (15) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (16) statement -> . IF L_PAR expression R_PAR statement
    (17) statement -> . WHILE L_PAR expression R_PAR statement
    (18) statement -> . L_BRC block R_BRC
    (19) statement -> . BREAK SEMI
    (20) statement -> . CONTINUE SEMI
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 4
    statement                      shift and go to state 109
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 101

    (47) arg_list -> expression COMMA arg_list .

    R_PAR           reduce using rule 47 (arg_list -> expression COMMA arg_list .)


state 102

    (11) statement -> LET IDEN COLON type SEMI .

    IDEN            reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    LET             reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    RETURN          reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    IF              reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    WHILE           reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    L_BRC           reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    BREAK           reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    CONTINUE        reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    L_PAR           reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    NUM_LIT         reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    BOOL_LIT        reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    STR_LIT         reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    PLUS            reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    MINUS           reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    NOT             reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    $end            reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    R_BRC           reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)
    ELSE            reduce using rule 11 (statement -> LET IDEN COLON type SEMI .)


state 103

    (13) statement -> LET IDEN COLON type ASSIGN . expression SEMI
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    IDEN            shift and go to state 43
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 110
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 104

    (12) statement -> LET IDEN ASSIGN expression SEMI .

    IDEN            reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    LET             reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    RETURN          reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    IF              reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    WHILE           reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    L_BRC           reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    BREAK           reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    CONTINUE        reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    L_PAR           reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    NUM_LIT         reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    BOOL_LIT        reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    STR_LIT         reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    PLUS            reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    MINUS           reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    NOT             reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    $end            reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    R_BRC           reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)
    ELSE            reduce using rule 12 (statement -> LET IDEN ASSIGN expression SEMI .)


state 105

    (15) statement -> IF L_PAR expression R_PAR statement . ELSE statement
    (16) statement -> IF L_PAR expression R_PAR statement .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 111
    IDEN            reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    LET             reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    RETURN          reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    IF              reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    WHILE           reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    L_BRC           reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    BREAK           reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    CONTINUE        reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    L_PAR           reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    NUM_LIT         reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    BOOL_LIT        reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    STR_LIT         reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    PLUS            reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    MINUS           reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    NOT             reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    $end            reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)
    R_BRC           reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .)

  ! ELSE            [ reduce using rule 16 (statement -> IF L_PAR expression R_PAR statement .) ]


state 106

    (52) lambda -> L_PAR R_PAR ARROW L_BRC block . R_BRC

    R_BRC           shift and go to state 112


state 107

    (53) lambda -> L_PAR param_list R_PAR ARROW L_BRC . block R_BRC
    (6) block -> . statement
    (7) block -> . statement block
    (8) statement -> . expression SEMI
    (9) statement -> . IDEN ASSIGN expression SEMI
    (10) statement -> . LET IDEN SEMI
    (11) statement -> . LET IDEN COLON type SEMI
    (12) statement -> . LET IDEN ASSIGN expression SEMI
    (13) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (14) statement -> . RETURN expression SEMI
    (15) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (16) statement -> . IF L_PAR expression R_PAR statement
    (17) statement -> . WHILE L_PAR expression R_PAR statement
    (18) statement -> . L_BRC block R_BRC
    (19) statement -> . BREAK SEMI
    (20) statement -> . CONTINUE SEMI
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    block                          shift and go to state 113
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 108

    (54) lambda -> L_PAR IDEN R_PAR ARROW L_BRC . block R_BRC
    (6) block -> . statement
    (7) block -> . statement block
    (8) statement -> . expression SEMI
    (9) statement -> . IDEN ASSIGN expression SEMI
    (10) statement -> . LET IDEN SEMI
    (11) statement -> . LET IDEN COLON type SEMI
    (12) statement -> . LET IDEN ASSIGN expression SEMI
    (13) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (14) statement -> . RETURN expression SEMI
    (15) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (16) statement -> . IF L_PAR expression R_PAR statement
    (17) statement -> . WHILE L_PAR expression R_PAR statement
    (18) statement -> . L_BRC block R_BRC
    (19) statement -> . BREAK SEMI
    (20) statement -> . CONTINUE SEMI
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    block                          shift and go to state 114
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 109

    (17) statement -> WHILE L_PAR expression R_PAR statement .

    IDEN            reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    LET             reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    RETURN          reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    IF              reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    WHILE           reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    L_BRC           reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    BREAK           reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    CONTINUE        reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    L_PAR           reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    NUM_LIT         reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    BOOL_LIT        reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    STR_LIT         reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    PLUS            reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    MINUS           reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    NOT             reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    $end            reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    R_BRC           reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)
    ELSE            reduce using rule 17 (statement -> WHILE L_PAR expression R_PAR statement .)


state 110

    (13) statement -> LET IDEN COLON type ASSIGN expression . SEMI
    (30) binary_operation -> expression . PLUS expression
    (31) binary_operation -> expression . MINUS expression
    (32) binary_operation -> expression . MULTIPLY expression
    (33) binary_operation -> expression . DIVIDE expression
    (34) binary_operation -> expression . MODULO expression
    (35) binary_operation -> expression . EQ expression
    (36) binary_operation -> expression . NEQ expression
    (37) binary_operation -> expression . LT expression
    (38) binary_operation -> expression . GT expression
    (39) binary_operation -> expression . LEQ expression
    (40) binary_operation -> expression . GEQ expression
    (41) binary_operation -> expression . OR expression
    (42) binary_operation -> expression . AND expression
    (50) function_call -> expression . L_PAR R_PAR
    (51) function_call -> expression . L_PAR arg_list R_PAR

    SEMI            shift and go to state 115
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    MULTIPLY        shift and go to state 28
    DIVIDE          shift and go to state 29
    MODULO          shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LEQ             shift and go to state 35
    GEQ             shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    L_PAR           shift and go to state 39


state 111

    (15) statement -> IF L_PAR expression R_PAR statement ELSE . statement
    (8) statement -> . expression SEMI
    (9) statement -> . IDEN ASSIGN expression SEMI
    (10) statement -> . LET IDEN SEMI
    (11) statement -> . LET IDEN COLON type SEMI
    (12) statement -> . LET IDEN ASSIGN expression SEMI
    (13) statement -> . LET IDEN COLON type ASSIGN expression SEMI
    (14) statement -> . RETURN expression SEMI
    (15) statement -> . IF L_PAR expression R_PAR statement ELSE statement
    (16) statement -> . IF L_PAR expression R_PAR statement
    (17) statement -> . WHILE L_PAR expression R_PAR statement
    (18) statement -> . L_BRC block R_BRC
    (19) statement -> . BREAK SEMI
    (20) statement -> . CONTINUE SEMI
    (21) expression -> . binary_operation
    (22) expression -> . unary_operation
    (23) expression -> . L_PAR expression R_PAR
    (24) expression -> . NUM_LIT
    (25) expression -> . BOOL_LIT
    (26) expression -> . STR_LIT
    (27) expression -> . function_call
    (28) expression -> . lambda
    (29) expression -> . IDEN
    (30) binary_operation -> . expression PLUS expression
    (31) binary_operation -> . expression MINUS expression
    (32) binary_operation -> . expression MULTIPLY expression
    (33) binary_operation -> . expression DIVIDE expression
    (34) binary_operation -> . expression MODULO expression
    (35) binary_operation -> . expression EQ expression
    (36) binary_operation -> . expression NEQ expression
    (37) binary_operation -> . expression LT expression
    (38) binary_operation -> . expression GT expression
    (39) binary_operation -> . expression LEQ expression
    (40) binary_operation -> . expression GEQ expression
    (41) binary_operation -> . expression OR expression
    (42) binary_operation -> . expression AND expression
    (43) unary_operation -> . PLUS expression
    (44) unary_operation -> . MINUS expression
    (45) unary_operation -> . NOT expression
    (50) function_call -> . expression L_PAR R_PAR
    (51) function_call -> . expression L_PAR arg_list R_PAR
    (52) lambda -> . L_PAR R_PAR ARROW L_BRC block R_BRC
    (53) lambda -> . L_PAR param_list R_PAR ARROW L_BRC block R_BRC
    (54) lambda -> . L_PAR IDEN R_PAR ARROW L_BRC block R_BRC

    IDEN            shift and go to state 5
    LET             shift and go to state 6
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    L_BRC           shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    L_PAR           shift and go to state 9
    NUM_LIT         shift and go to state 16
    BOOL_LIT        shift and go to state 17
    STR_LIT         shift and go to state 18
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    NOT             shift and go to state 23

    expression                     shift and go to state 4
    statement                      shift and go to state 116
    binary_operation               shift and go to state 14
    unary_operation                shift and go to state 15
    function_call                  shift and go to state 19
    lambda                         shift and go to state 20

state 112

    (52) lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .

    SEMI            reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    PLUS            reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    MINUS           reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    MULTIPLY        reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    DIVIDE          reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    MODULO          reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    EQ              reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    NEQ             reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    LT              reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    GT              reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    LEQ             reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    GEQ             reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    OR              reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    AND             reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    L_PAR           reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    R_PAR           reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)
    COMMA           reduce using rule 52 (lambda -> L_PAR R_PAR ARROW L_BRC block R_BRC .)


state 113

    (53) lambda -> L_PAR param_list R_PAR ARROW L_BRC block . R_BRC

    R_BRC           shift and go to state 117


state 114

    (54) lambda -> L_PAR IDEN R_PAR ARROW L_BRC block . R_BRC

    R_BRC           shift and go to state 118


state 115

    (13) statement -> LET IDEN COLON type ASSIGN expression SEMI .

    IDEN            reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    LET             reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    RETURN          reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    IF              reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    WHILE           reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    L_BRC           reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    BREAK           reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    CONTINUE        reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    L_PAR           reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    NUM_LIT         reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    BOOL_LIT        reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    STR_LIT         reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    PLUS            reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    MINUS           reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    NOT             reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    $end            reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    R_BRC           reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)
    ELSE            reduce using rule 13 (statement -> LET IDEN COLON type ASSIGN expression SEMI .)


state 116

    (15) statement -> IF L_PAR expression R_PAR statement ELSE statement .

    IDEN            reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    LET             reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    RETURN          reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    IF              reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    WHILE           reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    L_BRC           reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    BREAK           reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    CONTINUE        reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    L_PAR           reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    NUM_LIT         reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    BOOL_LIT        reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    STR_LIT         reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    PLUS            reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    MINUS           reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    NOT             reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    $end            reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    R_BRC           reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)
    ELSE            reduce using rule 15 (statement -> IF L_PAR expression R_PAR statement ELSE statement .)


state 117

    (53) lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .

    SEMI            reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    PLUS            reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    MINUS           reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    MULTIPLY        reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    DIVIDE          reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    MODULO          reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    EQ              reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    NEQ             reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    LT              reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    GT              reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    LEQ             reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    GEQ             reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    OR              reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    AND             reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    L_PAR           reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    R_PAR           reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)
    COMMA           reduce using rule 53 (lambda -> L_PAR param_list R_PAR ARROW L_BRC block R_BRC .)


state 118

    (54) lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .

    SEMI            reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    PLUS            reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    MINUS           reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    MULTIPLY        reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    DIVIDE          reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    MODULO          reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    EQ              reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    NEQ             reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    LT              reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    GT              reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    LEQ             reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    GEQ             reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    OR              reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    AND             reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    L_PAR           reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    R_PAR           reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)
    COMMA           reduce using rule 54 (lambda -> L_PAR IDEN R_PAR ARROW L_BRC block R_BRC .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for R_PAR in state 48 resolved as shift
WARNING: shift/reduce conflict for R_PAR in state 48 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 60 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 60 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 60 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 60 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 60 resolved as shift
WARNING: shift/reduce conflict for EQ in state 60 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 60 resolved as shift
WARNING: shift/reduce conflict for LT in state 60 resolved as shift
WARNING: shift/reduce conflict for GT in state 60 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 60 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 60 resolved as shift
WARNING: shift/reduce conflict for OR in state 60 resolved as shift
WARNING: shift/reduce conflict for AND in state 60 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 60 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 61 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 61 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 61 resolved as shift
WARNING: shift/reduce conflict for EQ in state 61 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 61 resolved as shift
WARNING: shift/reduce conflict for LT in state 61 resolved as shift
WARNING: shift/reduce conflict for GT in state 61 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 61 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 61 resolved as shift
WARNING: shift/reduce conflict for OR in state 61 resolved as shift
WARNING: shift/reduce conflict for AND in state 61 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 61 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 62 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 62 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 62 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 62 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 62 resolved as shift
WARNING: shift/reduce conflict for EQ in state 62 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 62 resolved as shift
WARNING: shift/reduce conflict for LT in state 62 resolved as shift
WARNING: shift/reduce conflict for GT in state 62 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 62 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 62 resolved as shift
WARNING: shift/reduce conflict for OR in state 62 resolved as shift
WARNING: shift/reduce conflict for AND in state 62 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 62 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 63 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 63 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 63 resolved as shift
WARNING: shift/reduce conflict for EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 63 resolved as shift
WARNING: shift/reduce conflict for LT in state 63 resolved as shift
WARNING: shift/reduce conflict for GT in state 63 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 63 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 63 resolved as shift
WARNING: shift/reduce conflict for OR in state 63 resolved as shift
WARNING: shift/reduce conflict for AND in state 63 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 63 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 64 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 64 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 64 resolved as shift
WARNING: shift/reduce conflict for EQ in state 64 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 64 resolved as shift
WARNING: shift/reduce conflict for LT in state 64 resolved as shift
WARNING: shift/reduce conflict for GT in state 64 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 64 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 64 resolved as shift
WARNING: shift/reduce conflict for OR in state 64 resolved as shift
WARNING: shift/reduce conflict for AND in state 64 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 65 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 65 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 65 resolved as shift
WARNING: shift/reduce conflict for EQ in state 65 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 65 resolved as shift
WARNING: shift/reduce conflict for LT in state 65 resolved as shift
WARNING: shift/reduce conflict for GT in state 65 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 65 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 65 resolved as shift
WARNING: shift/reduce conflict for OR in state 65 resolved as shift
WARNING: shift/reduce conflict for AND in state 65 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 65 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 66 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 66 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 66 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 66 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 66 resolved as shift
WARNING: shift/reduce conflict for EQ in state 66 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 66 resolved as shift
WARNING: shift/reduce conflict for LT in state 66 resolved as shift
WARNING: shift/reduce conflict for GT in state 66 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 66 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 66 resolved as shift
WARNING: shift/reduce conflict for OR in state 66 resolved as shift
WARNING: shift/reduce conflict for AND in state 66 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 66 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 67 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 67 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 67 resolved as shift
WARNING: shift/reduce conflict for EQ in state 67 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 67 resolved as shift
WARNING: shift/reduce conflict for LT in state 67 resolved as shift
WARNING: shift/reduce conflict for GT in state 67 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 67 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 67 resolved as shift
WARNING: shift/reduce conflict for OR in state 67 resolved as shift
WARNING: shift/reduce conflict for AND in state 67 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 67 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 68 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 68 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 68 resolved as shift
WARNING: shift/reduce conflict for EQ in state 68 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 68 resolved as shift
WARNING: shift/reduce conflict for LT in state 68 resolved as shift
WARNING: shift/reduce conflict for GT in state 68 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 68 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 68 resolved as shift
WARNING: shift/reduce conflict for OR in state 68 resolved as shift
WARNING: shift/reduce conflict for AND in state 68 resolved as shift
WARNING: shift/reduce conflict for L_PAR in state 68 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 105 resolved as shift
